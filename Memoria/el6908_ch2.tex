% 												CH2 - MARCO TEORICO
% En este capítulo se hace una revisión bibliográfica del los conceptos fundamentales para el desarrollo del trabajo de título. 
% Se puede considerar como una contextualización en cuanto sirve como base para comprender el trabajo realizado.

\acrodef{RAM}{\textit{Random Access Memory}}
\acrodef{RISC}{\textit{Reduced Instruction Set Computing}}
\acrodef{ALU}{\textit{Arithmetic Logic Unit}}
\acrodef{EULA}{\textit{End-User License Agreement}}
\acrodef{GPL}{\textit{General Public License}}
\acrodef{RTOS}{\textit{Real Time Operating System}}

\chapter{Contextualización}

\section{Marco Teórico}

Se deben revisar los siguientes temas que son parte del contexto del proyecto realizado.

% ============= SISTEMAS EMBEBIDOS ==============
\subsection{Sistemas embebidos}

%LEER Y CITAR EMBEDDED_ARCHITECTURE

Los sistemas embebidos a diferencia de un computador personal que es usado con fines generales para una amplia variedad de tareas, son sistemas computacionales normalmente utilizados para atender una cantidad limitada de procesos, realizar tareas específicas o dotar de determinada inteligencia a un sistema más complejo. Un sistema embebido está compuesto por uno o más microcontroladores pequeños que cuentan con periféricos para manejar diferentes protocolos de comunicación; conversores ADC; timers; puertos de entrada y salida digitales, todo en integrado en un mismo chip para guardar espacio y ahorrar energía. Parte fundamental de un sistema embebido es el software que provee la funcionalidad final, usualmente se usa el término firmware para referirse a este código con que se programa el microcontrolador el cual por lo general es específico para la plataforma de hardware y se relaciona a muy bajo nivel. A diferencia de un computador de propósito general donde el usuario puede cargar una serie de programas en 
él para un amplio rango de usos, el usuario de un sistema embebido no tiene la capacidad de reprogramarlo fuera de las posibilidades que el desarrollador ha brindado al sistema\cite{EMBEDDED_DESIGN}.\\

Para el diseño de sistemas embebidos se debe considerar ciertos aspectos que los diferencian de otros tipos de sistemas de computacionales, tales como\cite{SOFTWARE_ING}:

\begin{itemize}
	\item Un sistema embebido se mantiene siempre funcionando y debe proveer respuesta en tiempo real. Se debe diseñar considerando una operación continua y una posible reconfiguración del sistema estando ya en marcha.
	
	\item Las interacciones con el sistema pueden ser impredecibles y no se tiene control sobre ellas. Existen sistemas que son controlados por el usuario mediante una interfaz preparada para ellos, mientras que otros sistemas deben atender eventos imprevistos sin dejar de realizar tareas rutinarias.
	
	\item Existen limitaciones físicas. Normalmente estos sistemas poseen limitadas características de: poder de cómputo, memoria de datos y de programa; espacio físico; y disponibilidad de energía.
	
	\item El diseño de software para sistemas embebidos requiere una interacción de bajo nivel. Existe una amplia gama de plataformas de hardware para desarrollar sistemas embebidos y se requiere interactuar también con una amplia gama de dispositivos externos. Por esto se requiere desarrollar capas de drivers de periféricos que oculten las diferencias de hardware a la aplicación final del sistema.
	
	\item Es importante considerar aspectos de seguridad y confiabilidad del sistema durante todo su desarrollo debido a que la mayoría de los sistemas embebidos son usados para controlar otros sistemas críticos en diversos procesos.
\end{itemize}

\subsubsection{Microcontroladores PIC}

Todo sistema embebido está formado fundamentalmente por un microcontrolador que brinda la capacidad de cómputo y el control de diferentes periféricos que normalmente están integrados en el mismo chip. Entre los principales fabricantes de microcontroladores se encuentran: Microchip, Texas Instrument, ARM, Motorola, NVidia. Este trabajo se concentra en los microcontroladores PIC desarrollados por la compañía Microchip. La familia de microcontroladores  PIC es bastante amplia adaptándose a un amplio rango de necesidades, la tabla \ref{pic_list} resume las principales características de los diferentes modelos y puede ser utilizada como una guía para determinar el dispositivo adecuado según la aplicación:

% ················ TALBA ·················
\begin{table}[ht!]
\caption{Guía de microcontroladores PIC}\label{pic_list}
\centering \includegraphics[width=\textwidth]{img/pic_list.pdf}
\end{table}
%··········································

A continuación se describen las características específicas de los microcontroladores PIC24 que corresponde al dispositivo utilizado en este trabajo.

\paragraph{Arquitectura}
Poseen un juego de instrucciones \ac{RISC} (80 instrucciones) de ancho fijo en 24 bits que en su mayoría se ejecutan en un solo ciclo excepto: divisiones; cambios de contexto; y acceso por tabla a memoria de programa\cite{PIC24_PROG}. Se basa en una arquitectura Harvard modificada de 16 bits de datos\cite{PIC24F} lo que significa que el dispositivo posee una memoria de datos tipo \ac{RAM} separada de la memoria de datos (FLASH) pudiendo acceder de manera independiente e incluso simultáneamente a las instrucciones del programa y a los datos de este alojados en \ac{RAM}. La arquitectura de la CPU la completan una \ac{ALU} con \textit{hardware} dedicado para realizar multiplicaciones y divisiones. El detalle de la arquitectura del microcontrolador PIC24 se detalla en la figura \ref{pic_cpu}. También posee un vector de hasta 128 interrupciones con capacidad para atender hasta 8 de ellas lo que permite liberar al procesador de la espera de sucesos asíncronos ya que son notificados y atendidos de manera específica 
en una rutina de atención de la interrupción.

% ················ IMAGEN ·················
\begin{figure}[ht!]
\centering
\fbox{\includegraphics[scale=0.5]{img/pic_cpu.png}}
\caption{Arquitectura de la CPU del PIC24F}\label{pic_cpu}
\end{figure}
%··········································

\paragraph{Periféricos}
La familia de microcontroladores PIC24F integra en el mismo chip una serie de periféricos que permiten realizar funciones específicas a través de hardware especialmente diseñado. Esto hace que el PIC24F se convierta en un sistema embebido capaz de ser utilizados en aplicaciones que requieran: conversores análogos a digitales; temporizadores; comunicación síncronas y asíncronas como RS232, SPI o I2C; USB o Ethernet; manteniendo acotados los costos del sistema. Una lista de los periféricos disponibles para estos microcontroladores se detalla en la figura \ref{pic_perif}. El acceso para configurar, guardar y obtener datos de estos periféricos se realiza a través de registros que están mapeados en la memoria de datos del microcontrolador por lo tanto comparten el bus de datos y no son necesarias instrucciones extras para su integración. Junto con una completa documentación de la arquitectura y funcionamiento de cada periférico, los compiladores de lenguaje C de Microchip proveen librerías para acceder a estas 
funcionalidades a través de una API de más alto nivel.

% ················ IMAGEN ·················
\begin{figure}[ht!]
\centering
\fbox{\includegraphics[scale=0.5]{img/pic_perif.jpg}}
\caption{Arquitectura del PIC24F}\label{pic_perif}
\end{figure}
%··········································

\paragraph{Desarrollo}

% ============= SISTEMAS OPERATIVOS ==============
\subsection{Sistemas Operativos}
Un sistema operativo es la aplicación base de un sistema computacional pues brinda servicios básicos al resto de las aplicaciones de uso general que se ejecutan en el computador. El sistema operativo es la capa entre el hardware y las aplicaciones. El hardware puede variar considerablemente entre un sistema y otro, por eso se necesita una capa de abstracción que haga a la aplicación independiente de la plataforma en que se ejecuta. Para esto el sistema operativo provee servicios que usan interfaces de bajo nivel con el hardware las cuales no están disponibles para la aplicación. La figura \ref{os} es un esquema que ilustra un sistema operativo como una capa de abstracción del hardware. Ejemplos de sistemas operativos los son UNIX, GNU/Linux, FreeRTOS, entre otros.

% ················ IMAGEN ·················
\begin{figure}[ht!]
\centering
\fbox{\includegraphics[scale=0.5]{img/os.png}}
\caption{Sistema Operativo como capa de abstracción}\label{os}
\end{figure}
%··········································

\subsubsection{Sistemas Operativos de Tiempo Real}
Parte fundamental de un sistema operativo es su \textit{scheduler}, módulo encargado de intercambiar entre las múltiples tareas que se deben ejecutar cediendo un espacio de tiempo para utilizar le procesador. La forma en que trabaja el \textit{scheduler} define el tipo de sistema operativo que se posee. Un sistema operativo de tiempo real posee un \textit{scheduler} diseñado para proveer un flujo de ejecución determinista, pues solo sabiendo con exactitud la tarea que el sistema ejecutara en un determinado momento se pueden cumplir los requerimientos estrictos de \textit{timing}\cite{FREERTOS_PIC24}. Esto es un aspecto de especial interés en sistemas embebidos que normalmente requieren respuesta en tiempo real ante eventos no predecibles.\\

La figura \ref{rtos} demuestra la forma de conseguir un sistema de tiempo real mediante el uso de prioridades para las diferentes tareas. En este ejemplo la mayor parte del tiempo el sistema está en estado \textit{idle}, sin código que ejecutar. Sin embargo ante la precencia de ciertos evento el sistema debe responder de manera instantánea cambiado de contexto a la tarea correspondiente. Ciertas tareas pueden requerir un estricto \textit{timing} ejecutándose de manera periódica, por ejemplo. En este caso se asigna una alta prioridad para asegurar que el sistema operativo siempre ejecutara esta tarea cuando corresponda.

% ················ IMAGEN ·················
\begin{figure}[ht!]
\centering
\fbox{\includegraphics[scale=0.8]{img/rtos.png}}
\caption{\textit{Real time scheduling}}\label{rtos}
\end{figure}
%··········································

\subsubsection{FreeRTOS}
FreeRTOS es un tipo de \ac{RTOS} que está diseñado para ser lo suficientemente pequeño como para ser utilizado en un microcontrolador como sistemas embebidos\cite{FREERTOS}. Como estos sistemas son realmente limitados, normalmente no existe la posibilidad de ejecutar un sistema operativo completo como GNU-Linux, pero FreeRTOS provee un kernel capaz de manejar múltiples tareas con prioridades; comunicación entre tareas; \textit{timing} y primitivas de sincronización. Por su reducido tamaño no provee funcionalidades de alto nivel como una consola de comandos; así como tampoco funcionalidades de bajo nivel como controladores para el hardware o periférico. Entre sus principales características se encuentran:

\begin{itemize}
	\item \textit{Scheduler pre-emptive} o cooperativo.
	\item Sincronización y comunicación entre tareas a través de colas, semáforos, semáforos binarios y mutexes.
	\item Mutexes con herencia de prioridades.
	\item Software \textit{timers}.
	\item Bajo consumo de memoria (Entre 6K y 10K en ROM).
	\item Altamente configurable.
	\item Detección de \textit{stack overflow}
	\item Soporte oficial a 33 arquitecturas de sistemas embebidos.
	\item Estructura de código portable, escrito en C.
	\item Licenciado bajo \ac{GPL} modificada que permite su uso comercial sin publicar código fuente.
	\item Gratuito
	\item Amplia documentación, foros y asistencia técnica.
\end{itemize}

\paragraph{Funcionamiento}
Los conceptos fundamentales detrás del funcionamiento de FreeRTOS son las tareas y el \textit{scheduler}. Una tarea es un hilo de procesamiento, normalmente una función que se ejecuta de manera continua. Una tarea se puede encontrar dos estados fundamentales: ejecutándose y no ejecutándose. Cuando una tarea se está ejecutando tiene el control del procesador y el código dentro de la función que representa a la tarea es procesado. El estado ``no ejecutándose'' en realidad consta de tres sub-estados como se observa en la figura\ref{task_state}: se inicia en un estado ``listo'' lo que indica que la tarea está en condiciones de ser selecciona por el \textit{scheduler} y pasar a estado ``ejecutándose''; el estado ``bloqueado'' significa que la tarea no está disponible para ser ejecutada pues está en espera de algún evento, por ejemplo, la liberación de un mutex; cuando la tarea está en estado ``suspendida'' tampoco se puede ejecutar, la tarea debe explícitamente reanudarse para quedar en condiciones de ser 
ejecutada.

% ················ IMAGEN ·················
\begin{figure}[ht!]
\centering
\fbox{\includegraphics[scale=0.9]{img/task_state.png}}
\caption{Tareas de FreeRTOS, diagrama de estados}\label{task_state}
\end{figure}
%··········································

La creación de taras y el control de sus estados se realiza a través de la API de FreeRTOS que documenta claramente todas las posibles operaciones que se pueden realizar sobre una tarea.\\

El \textit{scheduler} es la parte fundamental del kernel que controla la ejecución de las diferentes tareas disponibles. Su objetivo es generar la sensación de estar en un ambiente multitarea, cuando en realidad sólo una tarea puede ejecutarse a la vez ya que se posee un solo procesador. Como se detalla en la figura \ref{scheduler} la función del \textit{scheduler} es entregar una porción de tiempo de ejecución fijo a una tarea y una vez que este tiempo se cumple se debe guardar el estado de ejecución de esta tarea y se procede a ejecutar otra. Así cada una de las tareas se ejecuta durante una pequeña porción de tiempo, hasta que completa su trabajo; si el tiempo de proceso asignado a cada tarea es lo suficientemente pequeño pareciera que muchas cosas ocurrieron simultáneamente. Claramente una sola tarea tomaría, en términos absolutos, menos tiempo en terminar si no fuera interrumpida, pero se gana un sistema más fluido cuando se deben ejecutar en conjunto tareas que toman mucho tiempo de proceso y otras 
relativamente cortas.

% ················ IMAGEN ·················
\begin{figure}[ht!]
\centering
\fbox{\includegraphics[scale=0.9]{img/scheduler.png}}
\caption{\textit{Scheduling} de tareas}\label{scheduler}
\end{figure}
%··········································

El algoritmo de \textit{scheduling} se basa en un sistema de prioridades, donde la tarea en condiciones de ejecutarse que tenga la mayor prioridad siempre debe ser ejecutada. Si varias tareas en estado ``listo'' comparten la misma prioridad se aplica un algoritmo de \textit{round-robing}. Las tareas que están en estado ``suspendido'' y ``bloqueado'' nunca son seleccionadas por el \textit{scheduler} y por lo tanto no consumen recursos. Haciendo un correcto uso de las prioridades y los diferentes estados se consigue un sistema que se ejecuta de manera fluida y haciendo un uso óptimo del procesador.

% \paragraph{Ejemplo de uso}


% ============= INGENIERIA DE SOFTWARE ==============
\subsection{Ingeniería de Software}

% ============= LICENCIAS DE SOFTWARE ==============
\subsubsection{Licencias de Software}
Se entiende por licencia de software a un contrato entre el desarrollador del software y el usuario final para su utilización según una serie de términos o condiciones. La licencia puede ceder ciertos derechos al usuario final; controlar la cantidad de copias que puede utilizar; el ámbito geográfico y temporal para la utilización; o bien proteger al desarrollador frente a la utilización del programa informático que se licencia. Existen al menos tres tipos de licencias de software:

\begin{itemize}
	\item \textbf{Privativas:}  El software es distribuido al usuario bajo un \ac{EULA} en que el propietario fija las condiciones de uso y se reserva la propiedad del programa informático. Generalmente impide el acceso al código fuente; la realización de ingeniería inversa; el uso del software por más de un usuario; se entrega el derecho de uso por un tiempo definido y por lo general provee cierta asesoría técnica. Es común que se debe pagar por el uso de un programa bajo este tipo de licencia.
	
	\item \textbf{Libres:} Este tipo de licencias otorgan al receptor la libertad de usar, estudiar, compartir y modificar el software. Existen varias licencias que cumplen con esta definición, por ejeplo: MIT, BSD, \ac{LGPL} y \ac{GPL}. Se dividen en dos tipos básicos licencias con \textit{copyleft} y sin \textit{copyleft}. Se habla de una licencia con \textit{copyleft} cuando esta indica que el software derivado debe mantener la misma licencia original impidiendo la generación de software privativo a partir de desarrollos libres, por ejemplo. Por lo general cumplir esta licencia requiere que se garantice el acceso al código fuente, de aquí el termino conocido como software de código abierto. La mayoría del software bajo estas licencias se distribuye de forma gratuita aunque su uso comercial no está necesariamente prohibido. No todo software gratuito es necesariamente software libre.
	
	\item \textbf{Dominio Público:} Si un programa informático se distribuye sin ningún tipo de licencia, se dice que es de dominio público. No posee ningún tipo de restricción sobre su uso, así como ninguna responsabilidad sobre sus creadores.
\end{itemize}

La aplicación de licencias se rige según las normativas legales locales. En el caso de las licencias libres por lo general basta con distribuir el texto de la licencia junto con la aplicación y agregar un encabezado indicando el tipo de licencia que se utiliza. Para atribuir autoría se suele utilizar las definiciones de la Convención de Berna, que indica que todo lo que se escribe queda automáticamente sujeto a copyright desde el momento en que la obra es fijada en un soporte material\cite{GNU}. En Chile la legislación vigente al respecto es la Ley 17.336 de propiedad Intelectual.

\subsubsection{\ac{GPL}}
La \ac{GPL} es una licencia de software creada en 1989 por la \textit{Free Software Foundation} que busca declarar que el software así licenciado es software libre y por lo tanto el usuario posee los siguientes derechos\cite{GPL}:
\begin{itemize}
	\item Libertad de usar el software para cualquier propósito.
	\item Libertad de modificar el software para adaptarlo a las propias necesidades.
	\item Libertad para compartir el software.
	\item Libertad para publicar los cambios que se han realizado.
\end{itemize}

Actualmente se encuentra en su versión 3.0 que a diferencia de versiones previas es una licencia con \textit{copyleft} y agrega cláusulas para proteger la libertad del usuario frente a nuevas prácticas en contra del software libre, tales como\cite{GPL}:
\begin{itemize}
	\item Tivoización: El término se refiere a la práctica de limitar los derechos de los usuarios que compran sistemas que funcionan con software libre mediante mecanismos de hardware, por ejemplo evitando la ejecución de versiones modificadas del software embebido.
	\item Leyes que prohíben software libre: Se asegura de que ciertas leyes puedan limitar los derechos del usuario de un software con licencia \ac{GPL}.
	\item Uso malicioso de patentes: Evita el uso indiscriminado de patentes, como por ejemplo, intentar obtener beneficios patentado desarrollos de software libre lo cual es una amenaza a la liberta de los usuarios.
\end{itemize}

\paragraph{Aplicación de la licencia} Para licenciar un proyecto de software libre bajo la \ac{GPL} V3.0 se deben seguir los siguientes pasos\cite{GNU}:
\begin{enumerate}
	\item Agregar un aviso informativo del \textit{copyright} al inicio de cada archivo con código fuente de la aplicación. Un ejemplo es la siguiente línea: \texttt{«Copyright 2012 Universidad de Chile»}
	
	\item Bajo el aviso de \textit{copyright} se agrega una autorización de copia indicando que el software se distribuye bajo los términos de la licencia \ac{GPL}. Un ejemplo de este aviso se cita en un ejemplo posterior.
	
	\item Se debe incluir junto al código fuente el texto completo de la licencia en un archivo llamado \texttt{LICENSE}. El texto de la licencia se puede obtener desde el siguiente enlace: \url{http://www.gnu.org/licenses/gpl.txt}.
\end{enumerate}

A continuación se detalla el encabezado que debería incluir cada fichero del proyecto de software hipotético llamado \texttt{Foobar}  que es licenciado bajo \ac{GPL}.

\begin{verbatim}
    Foobar - Description - «Copyright 2012 Universidad de Chile»
	
    This file is part of Foobar.

    Foobar is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Foobar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
\end{verbatim}

% \subsubsection{Arquitectura de Software}

% ============= CALIDAD DE SOFTWARE =============
\subsubsection{Calidad de software}
Los requerimientos no funcionales de un proyecto de software puede definirse como los parámetros de calidad buscados en producto en sí. Como parámetros de calidad se pueden entender una serie de calificativos muy subjetivos y tal vez difícilmente medibles como: rapidez, seguridad, escalabilidad o modularidad. Algunos conceptos pueden ser utilizados de manera poco clara o equivalentes como lo extensible o escalable que puede ser un software, sin dejar claro las diferencias o acotaciones de estos conceptos. Es por esto que se han creado normas en torno a las metodologías para desarrollar y utilizar modelos de calidad de software que permitan establecer de manera clara los parámetros a medir. 

En especial se tratará la norma ISO/IEC 25010, una actualización a la antigua norma ISO/IEC 9126, que plantea un modelo de calidad software que consta de ocho características con sus respectivos sub-atributos, y puede ser utilizado para evaluación o especificación de software durante las etapas de: identificación de requerimientos; validación de la integralidad de la lista de requerimientos; identificación de los objetivos del diseño del software; identificación de los objetivos de las pruebas; identificación de los criterios de calidad; o la definición de criterios para determinar si un producto de software está completo \cite{ISO25010}.

A continuación se definen los parámetros de calidad fijados en la norma ISO/IEC 25010 para productos de software, así como un resumen a través de la figura \ref{img:ch2:iso25010}.

\begin{itemize}
\item \textbf{Idoneidad Funcional}. Grado en que un producto provee la funciones requeridas.
	\begin{itemize}
	\item \textbf{Completitud funcional}. Grado en que las funciones cubren todas las tareas especificadas u objetivos.
	\item \textbf{Correctitud funcional}. Grado en que el producto provee resultados correctos según el grado de precisión.
	\item \textbf{Adecuación Funcional}. Grado en que las funciones facilitan el cumplimiento de las tareas requeridas.
	\end{itemize}

\item \textbf{Eficiencia del desempeño}. Desempeño relativo a la cantidad de recursos usado bajo ciertas condiciones.
	\begin{itemize}
	\item \textbf{Tiempo}. El grado en que el sistema cumple con requerimientos de tiempo de respuesta y tasa de rendimiento.
	\item \textbf{Utilización de recursos}. Grado en que la cantidad y tipos de recursos usados por el sistema cumple los requerimientos.
	\item \textbf{Capacidad}. Grado en que los límites máximos de un sistema cumplelos requerimientos
	\end{itemize}
\end{itemize}

\begin{itemize}
\item \textbf{Compatibilidad}. Grado en que el producto puede compartir información con otros productos o sistemas, y realizar sus funciones mientras se comparte el mismo entorno de hardware o software.
	\begin{itemize}
	\item \textbf{Coexistencia}. Cómo un producto puede llevar a cabo sus funciones mientras comparte un entorno y recursos comunes con otros productos sin afectarlos.
	\item \textbf{Interoperación}. Cómo un producto puede compartir y usar información con otro.
	\end{itemize}
\end{itemize}

\begin{itemize}
\item \textbf{Usabilidad}. Cómo el producto puede ser usado para sus fines determinados de manera efectiva, eficiente y satisfactoria.
	\begin{itemize}
	\item \textbf{Reconocible como apropiado}. Grado en que los usuarios pueden reconocer que el producto es apropiado para sus necesidades.
	\item \textbf{Aprendizaje}. Grado en que el producto se puede aprender a usar de manera efectiva, sin riesgos y satisfactoria.
	\item \textbf{Operatividad}. Grado en que el producto tiene atributos que lo hacen fácil de operar
	\item \textbf{Protección de cometer errores}. Grado en que el sistema protege al usuario de cometer errores.
	\item \textbf{Estética de la interfaz de usuario}. Grado en que la interfaz de usuario permite una interacción placentera y satisfactoria.
	\item \textbf{Accesibilidad}. Cómo el producto puede ser usado por personas con variedad de características y capacidades.
	\end{itemize}
\end{itemize}

\begin{itemize}
\item Fiabilidad. Grado en que el producto o sus componentes cumplen las funciones especificadas por un determinado periodo de tiempo.
	\begin{itemize}
	\item \textbf{Madurez}. Grado en que el sistema cumples las necesidades de fiabilidad bajo una operación normal.
	\item \textbf{Disponibilidad}. Grado en que el sistema es operacional y accesible cuando se requiere su uso.
	\item \textbf{Tolerancia a fallas.} Grado en que el sistema o sus componentes operan como es debido a pesar de la ocurrencia de fallos de software o hardware.
	\item \textbf{Capacidad de recuperación}. La capacidad del sistema de recuperar los datos afectados y restablecer el estado deseado del sistema ante una interrupción o falla.
	\end{itemize}
\end{itemize}

\begin{itemize}
\item \textbf{Seguridad}. Cómo un sistema protege la información y los datos de modo que las personas, productos o sistemas tengan el grado de acceso a los datos adecuados a sus tipos y niveles de autorización.
	\begin{itemize}
	\item \textbf{Confidencialidad}. Grado en que el sistema asegura que los datos sólo son accesibles por las personas autorizadas.
	\item \textbf{Integridad}. Grado en que el sistema previene el acceso y modificación de los datos o programas.
	\item \textbf{No rechazo}. Grado en que es posible demostrar que las acciones han tenido lugar, para no poder ser negadas más tarde.
	\item \textbf{Responsabilidad}. Grado en que las acciones de una entidad puedes ser asociadas de manera inequívoca a esa entidad.
	\item \textbf{Autenticidad}. Grado en que la identidad de un sujeto o recurso puede ser comprobada.
	\end{itemize}

\item \textbf{Mantenimiento}. Grado de la eficiencia y eficacia con la que un
producto o sistema puede ser modificado por los mantenedores.
	\begin{itemize}
	\item \textbf{Modularidad}. Grado en que un sistema o software está compuesto por componentes discretos de modo que el cambio en un componente tiene mínimo impacto en el resto del sistema.
	\item \textbf{Reusabilidad}. Grado en que un activo puede ser usado en más de un sistema, o en la construcción de otro.
	\item \textbf{Analizable}. Grado en de eficiencia y eficacia con que es posible identificar el impacto de un cambio en una parte del sistema, o diagnosticar deficiencias o fallas en alguna de sus partes, o identificar las partes que deben ser modificadas.
	\item \textbf{Modificable}. Grado en el sistema puede ser modificado de manera efectiva y eficiente, sin introducir defectos o degradar la calidad existente.
	\item \textbf{Testeable}. Grado en que es posible establecer un criterio para probar el sistema y las pruebas que pueden ser desarrolladas para determinar que el criterio se ha cumplido.
	\end{itemize}

\item \textbf{Portabilidad}. Grado de la eficiencia y eficacia con la que un producto o sistema puede ser transferido de un hardware, software u ambiente de uso a otro diferente.
	\begin{itemize}
	\item \textbf{Adaptabilidad}. Grado en que el producto puede ser adaptado a un hardware o software diferente de manera eficiente y efectiva.
	\item \textbf{Instalación}. Grado de efectividad y eficiencia con que el sistema puede ser instalado o desinstalado.
	\item \textbf{Reemplazo}. Grado en que el producto puede reemplazar a otro para el mismo propósito en el mismo ambiente.
	\end{itemize}
\end{itemize}

%Figura - Esquema ISO25010
\figura{img/ISO25010.jpg}{width=\textwidth}{ISO/IEC 25010, categorías y subcategorías.}{img:ch2:iso25010}{!h}

%Explicar como se aplica este modelo a un proyecto de software

% \subsection{Arquitectura de Software}
%LEER Y CITAR EMBEDDED_ARCHITECTURE

% ============= PATRONES DE DISEÑO ==============
\subsection{Patrones de diseño}\label{ch2:sec:214}
En computación, especialmente en la programación orientada a objetos, se utilizan patrones para sortear la difuctad de generar buenos diseños seleccionando los objetos pertinentes y sus correspondientes relaciones dentro de a aplicación. Los programadores experimentados tienden a reutilizar soluciones bien probadas para luego apadtarlas al contexto específico de un nuevo problema generando una metodología general para resolver cierta clase de problemas, estas metodologías son llamadas patrones de diseño y se encuentran bien documentas para su aplicación sucesiva en cada nueva aplicación.\cite{DESIGN_PATTERNS}

Un patrón de diseño por lo tanto, describe un problema de diseño particular y recurrente dentro de cierto contexto, presentando esquema genérico y bien probado que resulve este problema. El patrón describe los componentes que consitutyen la solución, sus responsabilidades, relaciones y la forma en que colaboran entre sí.\cite{SYSTEM_PATTERNS}

Los patrones de diseño se encuentran documentados de manera bien homogénea a través de una plantilla que permite comprender rápidamente los siguientes aspectos fundamentales del diseño: cuál es el problema que se resuelve; cuál es la solución propuesta; y las consecuencias de su aplicación tales como ventajas y desventajas. Para ejemplificar a continuación se detallará uno de los ejemplos clásicos de patrones de diseño, denominado Modelo-Vista-Controlador.\cite{SYSTEM_PATTERNS}

\paragraph{Modelo-Vista-Controlador.} Este patrón de diseño divide una aplicación interactiva en tres componentes: el modelo, que contiene la funcionalidad base y los datos; la vista, que despliega la información al usuario; y el controlador, que maneja la entrada del usuario para cambiar el estado de la aplicación. Así, la interfaz gráfica se refleja en el controlador y la vista, donde cada acción se propaga a través del controlador hacia el modelo, actualizando a la vez la vista.\cite{DESIGN_PATTERNS}\cite{SYSTEM_PATTERNS}

\begin{itemize}
    \item \textbf{Contexto:} aplicaciones interactivas son un interfaz de usuario flexible.
    
    \item \textbf{Problema:} el diseño de una interfaz gráfica de usuario que esté desacoplada del programa principal. La interfaz gráfica por lo general debe ser flexible, permitiendo cambios en su distribución o la forma de llamar a las funcionalidades o varios métodos de entrada que llamando a la misma funcionalidad como botones, linea de comandos o menús. También se puede requerir portar la interfaz gráfica a diferentes ambientes o estándares manteniendo la funcionalidad de la aplicación. Otro caso típico corresponde a la visualización de la misma información de diferentes maneras o en diferentes ventana, como lo pueden ser vistas de gráficos o tablas para los mismos datos, por lo tanto se requiere desacoplar los datos de la vista para evitar la duplicación o corrupción de la información.
    
    \item \textbf{Solución:} dividir la aplicación en tres áreas: el modelo, la vista y el controlador. Donde el modelo controla la lógica y funcionalidades internas de la aplicación, la vista gestiona la representación de la aplicación hacia el usuario y el controlador maneja las entradas del usuario.
    
    El usuario sólo interactúa con el controlador, y los cambios realizados en el modelo debe ser propagados hacia la vista. Como cada vista comparte el modelo, los cambios se verán actualizados en cada una de ellas.
    
    \item \textbf{Estructura:} los componentes que completan la estructura del patrón MVC se detallan a continuación:
    \begin{itemize}
        \item \textbf{Modelo:} encapsula la información y todas las funcionalidades de la aplicación, de manera independiente de su representación gráfica. Provee los métodos para realizar los procesos específicos de la aplicación así como para acceder a los datos de esta. A la vez implementa el mecanismo de propagación de los cambios hacia las diferentes vista suscritas a este modelo.
        
        \item \textbf{Vista:} despliega la información al usuario, a partir de los datos del modelo. Permite múltiples formas de visualizar el modelo. Provee un método de actualización que es activado por el mecanismo de propagación de cambios del modelo suscrito.
        
        \item \textbf{Controlador:} cada vista tiene asociado un controlador que recibe la entrada del usuario, como presionar un botón o seleccionar una entrada de menú. El controlador solicita el servicio correspondiente al modelo, causando a la vez una actualización de la vista si es necesario.
    \end{itemize}
    
    Para clarificar las relaciones entre los componentes del patrón se cuenta con el diagrama de la figura \ref{ch2:patterns:mvc:classes}. La esencia dinámica del patrón en ejecución se observa a través del diagrama de colaboración detallado en la figura \ref{ch2:patterns:mvc:collaboration}    
    
    \item \textbf{Consecuencias:} alguno de los beneficios que provee son: múltiples vistas para el mismo modelo; vistas sincronizadas dado que los cambios en el modelo se propagan a las vistas que lo comparten; vista y controlador intercambiable de manera independiente del modelo, permitiendo portar la aplicación a diferentes plataformas sin cambiar la funcionalidad. Por otro lado los inconvenientes que genera son: aumento de complejidad, al necesitar adaptar cada elemento de la vista al controlador y funcionalidades; excesivo número de actualizaciones al propagar cambios del modelo a todas las vistas; alto acoplamiento entre la vista y el controlador, aún como elementos separados su diseño está muy relacionado; acoplamiento entre el modelo y el conjunto vista-controlador, ya que cualquier cambios en la interfaz de los servicios que provee el modelo tiene un efecto directo en el funcionamiento de la vista y el controlado pues acceden directamente a estos servicios.
    
\end{itemize}

\figura{img/mvc_class.png}{width=0.8\textwidth}{Diagrama de clases del patrón de diseño MVC.}{ch2:mvc:command:classes}{!h}

\figura{img/mvc_colab.png}{width=0.8\textwidth}{Esquema de colaboración del patrón de diseño MVC.}{ch2::mvc:command:collaboration}{!h}

Como se ve, el proceso de diseño de una aplicación, parte por la busca de patrones de diseño claramente documentados y que soluciones un tipo de problema similar al buscado. Comparar patrones de diseño cuando se tienen varios candidatos a solucionar el problema también se hace sencillo en cuanto la forma de presentar cada patrón permite obtener sus principales características y posible implementación.  Además una aplicación puede hacer uso de varios patrones de diseño en diferentes niveles de su arquitectura para cumplir la totalidad de las especificaciones.

No obstante se debe considerar que el patrón de diseño en sí, no entregará la solución completa a un problema concreto, en cuanto sólo presenta una visión general de la solución, sin ahondar en los detalles de implementación o funcionalidades específicas del problema en cuestión. Los patrones de diseño resuelven una clase de problema relacionado, si el problema que se busca solucionar corresponde con los alcances de algún patrón de diseño, se tiene el punto de partida para la solución, pero se debe adaptar y completar el esquema original con los requerimientos y funcionalidades específicas de la nueva aplicación.

\subsubsection{Arquitecturas de software basadas en patrones}
Si bien el diseño de aplicaciones basadas en patrones está muy enfocada en la programación orientada a objetos y se beneficia de sus posibilidades, esta técnica se puede extender más allá y ser aplicada en cualquier paradigma o lenguaje de programación. En efecto a nivel de diseño de arquitectura de software, la mayoría de los patrones requieren cierta capacidad de abstracción del lenguaje de programación como módulos o estructuras de datos\cite{SYSTEM_PATTERNS} lo cual abre las posibilidades de utilizar esta técnica de diseño sobre lenguajes procedurales como los utilizados en la programación de sistemas embebidos.



\subsubsection{Command Pattern}
Dentro de los patrones clasificados como de comportamiento se encuentra el patrón de procesador de comandos o mejor conocido por su nombre en inglés \textit{command pattern}\cite{DESIGN_PATTERNS} o \textit{command processor pattern}\cite{SYSTEM_PATTERNS} el cual es de especial interés en este trabajo. Lo esencial de este patrón es separar el requerimiento de un servicio de su ejecución, encapsulándolo en la forma de un comando.

\begin{itemize}
    \item \textbf{Contexto:} Aplicaciones que requieren flexibilidad al añadir funcionalidades. Interfaces gráficas flexibles y extensibles. Aplicaciones orientadas a la ejecución de funciones por parte del usuario soportando características como llevar un registro de ejecución o deshacer acciones. Aplicaciones donde el instante de generación de un requerimiento es independiente del instante en que se ejecuta.
    
    \item \textbf{Problema:} Una aplicación que requiere dar soporte a una gran cantidad de funcionalidades, se puede ver beneficiada del aislar la forma genérica en que se realiza el llamado a esta función de su implementación misma. También cuando se requiere implementar funcionalidades como registro de eventos, deshacer, macros o suspender cierta ejecución de un proceso, se ve la necesidad de separar las funcionalidades del núcleo de la aplicación que las gestiona. Una aplicación que requiere ser altamente escalable sin afectar el código existente debe encontrar una manera homogénea de agregar estas funcionalidades nuevas.
    
    \item \textbf{Solución:} Encapsular los requerimientos en objetos llamados comandos, así cada llamada a una función específica crea un nuevo comando, también específico a esa llamada que implementa la funcionalidad. El patrón describe la estructura de gestión para la generación y ejecución de los comandos la cual es homogénea para cada comandos requerido. Las adaptabilidad y extensión de la aplicación se realiza mediante la implementación de nuevos comandos sobre el sistema de gestión base.
    
    \item \textbf{Estructura:} La arquitectura está compuesta por los siguientes módulos.
    \begin{itemize}
        \item \textbf{Comando:} Todos los comandos poseen una estructura básica, implementando un método para ejecutar el comando. Para cada función requerida en la aplicación se crea una derivación de la estructura base del comando que implementa la lógica requerida del comando.
        \item \textbf{Controlador o cliente:} Representa la interfaz de la aplicación y para cada requerimiento crea el comando adecuado el que es transferido al procesador de los comandos.
        \item \textbf{Procesador de comandos o \textit{invoker}:} Recibe los comandos, agenda e inicia su ejecución. Este módulo es independiente de cada comando, en cuanto sólo utiliza la interfaz genérica que cada comando debe respetar.
        \item \textbf{Proveedor o receptor:} Provee la funcionalidad del comando en sí ya que la lógica de ejecución del comando incluye el llamado uno o varios del los servicios entregados por el proveedor.
    \end{itemize}
    El diagrama de la figura \ref{ch2:patterns:command:classes} detalla las relaciones entre los diferentes módulos o clases del patrón. La dinámica de la arquitectura se rescata en en la figura \ref{ch2::patterns:command:collaboration} que corresponde a un diagrama de colaboración entre los elementos de la estructura descrita.
    
    \item \textbf{Consecuencias:} La aplicación de este patrón de diseño implica los siguientes beneficios:
    \begin{itemize}
        \item Los comandos pueden ser requeridos de manera flexible, según se implemente el controlador. De hecho podrían existir más de un controlador o cliente generando el mismo comando desde diferentes modos.
        \item La aplicación es fácil de modificar y extender a través de la implementación de nuevos comandos dado que el procesador de comandos sólo trabaja con la interfaz genérica del comandos. Es posible agregar comandos más complejos combinando los ya existentes en una especie de macro.
        \item El procesador de comandos al centralizar la gestión de estos es el lugar adecuado para implementar servicios como:registro de comandos ejecutados; filtrar la ejecución de comandos; posponer, repetir o deshacer la ejecución de comandos; o gestionar un sistema de prioridades entre comandos.
    \end{itemize}
    
    Entre las ventajas y limitaciones de este diseño conviene mencionar:
    \begin{itemize}
        \item La cantidad de comandos puede crecer considerablemente aumentando la complejidad de la aplicación.
        \item La retroalimentación entre la ejecución del comando y el cliente que lo crea puede ser limitada.
        \item Al desacoplar el momento de generar el comando con el momento de la ejecución en sí, pueden existir limitaciones en implementar aplicaciones basadas en eventos pues el comando obtendrá algunos parámetros de la aplicación sólo durante su ejecución.
    \end{itemize}

\end{itemize}

\figura{img/command_processor_class.png}{width=0.8\textwidth}{Diagrama de clases del patrón de diseño procesador de comandos.}{ch2:patterns:command:classes}{!h}

\figura{img/command_processor_colab.png}{width=0.8\textwidth}{Esquema de colaboración del patrón de diseño procesador de comandos.}{ch2::patterns:command:collaboration}{!h}

% ============= SATELITES ==============

\subsection{Pequeños Satélites}
%TODO: Agregar una descripcion breve

\subsubsection{Satélites tipo Cubesat}
A partir del año 1999 se comienza a desarrollar el proyecto Cubesat como una iniciativa entre \textit{California Polytechnic State University, San Luis Obispo} y \textit{Stanford University}. Con el objetivo proveer acceso al espacio a pequeños \textit{payloads} en un corto periodo de desarrollo y abajo costo se provee un nuevo estándar para pico-satélites denominado Cubesat. El estándar considera satélites de pequeñas dimensiones, acotados a un cubo de 10 [cm] de arista y un peso máximo de 1.3 [kg] como el detallado en la figura \ref{img:ch2:cubesat} (a). El proyecto contempla tanto las especificaciones generales del satélite así como una plataforma estándar para desplegar los satélites desde el vehículo de lanzamiento, denominada P-POD. Cada P-POD consiste en un compartimiento capaz de albergar tres Cubesat y desplegarlos mediante una sistema de resortes ante la señal generada por el vehículo de lanzamiento. La figura \ref{img:ch2:cubesat} (b) detalla la estructura de un P-POD.

%···················· FIGURE ····················
\begin{figure}[ht!] \centering
\subfloat[Cubesat]{\includegraphics[scale=0.6]{img/cubesat.jpg}} \hspace{0.5cm}
\subfloat[P-POD]{\includegraphics[scale=0.6]{img/ppod.jpg}}
\caption{Satélite tipo Cubsat}\label{img:ch2:cubesat}
\end{figure}
%···············································

\paragraph{Estándar.} Las restricciones que fija el estándar Cubesat se detallan formalmente en las especificaciones de diseño desarrolladas por \textit{California Polytechnic State University}\cite{CUBESAT_CDS} y a continuación se detallan las principales consideraciones:
\begin{itemize}
	\item \textbf{Requerimientos generales}
	\begin{itemize}
		\item Todos los componentes deben estar fijos al satélite durante el lanzamiento, despliegue y operación. No se permite liberar elementos extras al espacio.
		\item No se permite ningún tipo de elemento explosivo o pirotécnico.
		\item La energía química almacenada no debe superar los 100 [Wh]
	\end{itemize}

	\item \textbf{Requerimientos Mecánicos}
	\begin{itemize}
		\item La configuración y dimensiones del satélite deben estar de acuerdo a la figura \ref{img:ch2:cds}
		\item El cubo debe tener dimensiones de 100x100x113 [mm] en x,y,z respectivamente según la figura \ref{img:ch2:cds}
		\item Los componentes no deben sobresalir más de 6.5 [mm] en dirección normal a cada cara.
		\item Sólo los rieles exteriores de la estructura pueden tener contacto con el P-POD.
		\item El satélite no debe superar los 1.33 [kg] de masa.
		\item La estructura externa debe estar construida en aluminio 7075 o 6061.
	\end{itemize}

	 \item \textbf{Requerimientos Eléctricos}
	 \begin{itemize}
	 	\item Ningún componente electrónico debe estar activo durante el lanzamiento, esto incluye desactivar completamente o descargar las baterías.
	 	\item El Cubesat debe poseer un interruptor en la base de uno de sus rieles que permita apagar completamente el satélite cuando está presionado.
	 	\item Adicionalmente debe contar con un conector tipo \textit{Remove Before Flight} que debe cortar toda la energía del satélite y será removido una vez se integre en el P-POD.
	 \end{itemize}
	 
	 \item \textbf{Requerimientos de operación}
	 \begin{itemize}
	 	\item Cubesat con baterías deben ser capaces de recibir el comandos para apagar transmisiones según las regulaciones de la FCC.
	 	\item Todos los mecanismos de despliegue del satélite no se deben activar antes de 30 minutos luego del despliegue desde el P-POD.
	 	\item Transmisores de rados de potencia mayor a 1mW no debe transmitir antes de cumplirse 30 minutos luego del despliegue desde el P-POD.
	 	\item Se debe contar con la licencia de uso de frecuencia de radio. Para frecuencias \textit{amateur} la coordinación se realiza a través de la \textit{International Amateur Radio Union} [IARU].
	 \end{itemize}

\end{itemize}

El estándar mencionado corresponde a un Cubesat de una unidad (1U). Adicionalmente se pueden combinar hasta tres unidades para obtener Cubesat de 2U o 3U y así contar con mayor volumen para posicionar los componentes físicos del satélite y una mayor superficie para situar panales solares que brinden mayor autonomía energética.

\figura{img/cubesat_cds.png}{width=\textwidth}{Especificaciones de diseño del estándar Cubsat}{img:ch2:cds}{!h}

\paragraph{Aplicaciones}
En la actualidad cerca de un centenar de satélites tipo Cubesat han sido lanzados de manera exitosa. Las aplicaciones con posibilidades de ser desarrolladas a través de este tipo de tecnologías incluyen proyectos con fines educacionales, pruebas de nuevas tecnologías espaciales, proyectos de investigación científica y desarrollos privados.

Desde el punto de vista educacional, dadas las características de rápido desarrollo y a un costo comparativamente bajo, este tipo de tecnologías abre las posibilidades de investigación y desarrollo de proyectos en materia aeroespacial a instituciones educaciones y gobiernos de todo el mundo, teniendo como antecedente que la mayoría de los proyectos de satélites Cubesat han sido desarrollados por estudiantes en universidades utilizando componentes comerciales o desarrollos propios. El valor educacional de un proyecto satelital de estas características incluye: el desarrollo de nueva tecnología aeroespacial, que puede ser probada a pequeña escala en ambientes realistas; la formación de profesionales entrenados en el área mediante la experiencia práctica que brinda la ejecución de este tipo proyectos; la aplicación de metodologías en la formación académica que incluyan el trabajo en equipos multidisciplinarios.

Contando con una plataforma estándar de vehículo espacial se abre la posibilidad al desarrollo de diferentes \textit{payloads} de tipo científico capaces de tomar diferentes datos en el espacio abriendo las posibilidades de desarrollar investigación científica. Entre las aplicaciones más destacadas se encuentra la observación remota de la tierra mediante el uso de sensores para tomar datos sobre la ionosfera y termosfera, o el uso de cámaras fotográficas que provean imágenes para un estudio posterior. Este tipo de misiones y sus datos pueden ser llegar incluso a poner a prueba sistemas de predicción o alerta temprana de desastres\cite{BECERRA_DIAZ}.

Iniciativas privadas o de propósito general tales como redes de comunicaciones de apoyo en caso de catástrofe, redes de comunicaciones privadas, monitoreo remoto de plantaciones y proyectos de exploración minera son algunas de las posibles aplicaciones capaces de ser desarrolladas como un proyecto aeroespacial tipo Cubesat.

% ============= ANTECEDENTES GENERALES ==============
% \section{Antecedentes generales}
% \paragraph{Carrera satelital chilena}


% ============= ANTECEDENTES ESPECIFICOS =============
\section{Proyecto SUCHAI}
El proyecto SUCHAI (\textit{Satellite of University of Chile for Aerospace Investigation}) es el proyecto satelital desarrollado por el Departamento de Ingeniería Eléctrica de la Universidad de Chile con la participación de académicos, ingenieros y estudiantes. El proyecto consiste en el desarrollo, puesta en órbita y operación del primer satélite desarrollado netamente en el país.

\figura{img/suchai_logo.png}{scale=0.3}{Logo del proyecto SUCHAI}{img:ch2:suchai_logo}{!h}

Se trata de un satélite tipo Cubesat de una unidad con fines educacionales y científicos. El objetivo del proyecto es poner en órbita un satélite, desarrollado por estudiantes de la carrera de ingeniería, que sea capaz de enviar un \textit{beacon} a ser escuchado y decodificado por la estación terrena, ejecutar experimentos asociados a \textit{payloads} guardando estos datos y enviar como telemetría a la estación terrena la información de funcionamiento del satélite y los datos de los diferentes \textit{payloads}. Por otro lado, el desarrollo del proyecto permitirá adquirir el conocimiento necesario para desarrollar proyectos satelitales de manera local que será la base para futuras misiones relacionadas. Además permitirá integrar a alumnos de pregrado en el desarrollo de un proyecto multidisciplinario que requiere proponer soluciones no triviales a un problema abierto.

El satélite se compone de tres sistemas básicos: el computador a bordo, que consiste en un microcontrolador de gama media para ejecutar el \textit{software} que controla la operación del satélite en vuelo; el sistema de comunicaciones compuesto por un transmisor y receptor de radio UHF así como antenas a desplegar durante la operación; y un sistema de control de energía o EPS que incluya baterías y panales solares para proveer la energía eléctrica que permite operar al satélite así como cargar las baterías. Como carga útil se considera la integración de: una cámara digital que pueda realizar tomas de la tierra; sensores de temperatura; giróscopos; un sensor para medir la densidad y temperatura de la ionosfera tipo \textit{langmuir probe}; dispositivo para realizar un estudio estadístico de la transferencia de potencia en ambientes de microgravedad y la disipación de calor de la electrónica en ambientes escasos de aire.

% \subsection{Investigaciones asociadas}
% \paragraph{Lagmuir Probe}
% \paragraph{Experimento de física} 
