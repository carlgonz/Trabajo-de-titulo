\chapter{Implementación}

En este se describe el proceso de implementar la arquitectura para el software de vuelo de un nano-satélite diseñada en el capítulo \ref{ch3}. El proceso de implementación se concentrará en completar los requerimientos mínimos del sistema para alcanzar cierta generalidad que convierta al presente trabajo en la base de futuras misiones satelitales. En este sentido se evitará la discusión de detalles de implementación específicos de la misión del proyecto SUCHAI, para lo cual se puede tomar como referencia el trabajo desarrollado en torno al diseño e integración del proyecto\cite{TOOPAZO}. En la misma línea, al presentar en primer lugar la implementación del núcleo de la aplicación como base de la característica de reusabilidad, se demuestra la capacidad de modificabilidad del sistema al agregar de manera incremental nuevas funcionalidades que completen los requerimientos esperados.

El proceso de implementación consta de tres etapas principales, que se alinean con la visión global del sistema en forma de arquitectura de tres capas. En primer lugar se detallan los drivers que se requieren implementar para esta plataforma de hardware específico, definiendo el tipo de arquitectura utilizada en el driver para guiar la implementación. En segundo lugar se detalla la forma de integrar el sistema operativo preparando al sistema para montar la aplicación final. Y por último la aplicación final se implementará módulo a módulo hasta lograr un sistema funcional.

\section{Ambiente de desarrollo}
La implementación del proyecto comienza por la definición del entorno y herramientas de desarrollo disponibles, pues son elementos esenciales que definen las posibilidades, limitaciones y marco de trabajo durante todo el proceso. El ambiente de desarrollo incluye los siguientes elementos: computadores, sistema operativo, control de versiones, el ambiente de desarrollo integrado o IDE, compilador, programador del microcontrolador y tarjeta de desarrollo.

\paragraph{Computadores.} En general para el desarrollo de software no se tienen requerimientos de hardware elevados, considerando que bastaría con ejecutar un procesador de texto, una aplicación de linea de comandos para ejecutar el compilar y la disponibilidad de al menos un puerto USB para utilizar el programador del microcontrolador. La aplicación más demandante en recursos es el IDE (ver \ref{ch4:para:ide}) cuyos requerimientos recomendados de hardware se encuentran en la tabla \ref{ch4:table:hardware_req}.

\begin{table}[ht!] \caption{Requerimientos de hardware recomendados para desarrollo}
\centering
\begin{tabular}{ll}\hline
\textbf{Procesador} & Intel Pentium 4 @ 2.6 GHz o equivalente\\
\textbf{Memoria RAM} & 2 GB\\
\textbf{Espacio en disco} & 1 GB\\\hline
\end{tabular} \label{ch4:table:hardware_req}
\end{table}

\paragraph{Sistema Operativo.} En principio no existen restricciones sobre el sistema operativo a utilizar dado que las principales herramientas como el IDE y el compilador son multiplataforma. Sin embargo el presente trabajo se ha desarrollado sobre plataformas GNU/Linux por su flexibilidad, libertad de distribución, disponibilidad de herramientas y estabilidad. Las principales distribuciones de Linux utilizadas fueron Kubuntu 12.04 LTS amd64 y LinuxMint 14 amd64.

\paragraph{Control de versiones.} Un sistema adecuado de control de cambios es fundamental en el desarrollo de un proyecto de software, incluso para el desarrollo de software de sistemas embebidos. Un sistema de control de versiones permite no sólo mantener un registro de los cambios incrementales del código, si no también revertir estos cambios, abrir ramas paralelas de desarrollo y el trabajo colaborativo entre un equipo de programadores. En este proyecto se utilizó el software Subversion con un servidor propio dedicado netamente a proveer el servicio de almacenamiento remoto del código junto al control de versiones. Subversion permite mantener un repositorio remoto y hacer copias de trabajo locales en el equipo de cada desarrollador (\textit{chekout}). Los programadores realizan cambios sobre el código y suben las modificaciones al servidor como una nueva versión (\textit{commit}), estos cambios se ven reflejados cuando el resto del equipo sincroniza sus copias de trabajo con el servidor remoto (\textit{update}). Existe una amplia gama de software de control de versiones, en particular se recomienda el uso de Git que posee como principal característica ser un sistema distribuido donde cada copia local actúa como un repositorio en si mismo haciéndolo más robusto. Si no se cuenta con servidores propios, se pueden utilizar servicio de almacenamiento de repositorios en línea, como GitHub, que se integra con Git y es gratuito para repositorios públicos.

\paragraph{IDE.}\label{ch4:para:ide} El ambiente de desarrollo integrado o IDE es la aplicación fundamental del proceso, un buen ambiente de desarrollo proveerá las herramientas adecuadas para el desarrollo organizado y consistente del software integrando el editor de texto, servicio de control de versiones, integración con el compilador, integración con el programador, sistema de \textit{debug}, sistema de documentación entre otros. En el caso de este proyecto se utiliza el entorno de desarrollo integrado de Microchip MPLAB X que se caracteriza por ser un entorno multiplataforma, basado en el proyecto de código libre NetBeans. Este IDE integra un avanzado editor de texto, con funcionalidades de control de cambios locales, múltiples configuraciones para un mismo proyecto, integración con múltiples compiladores y acceso directo a la programación del dispositivo todo desde la misma aplicación centralizando todo el proceso de desarrollo en un ambiente adecuado.

\figura{img/mplabx.png}{width=\textwidth}{Entorno de desarrollo integrado MPLABX}{img:ch4:mplabx}{!h}

\paragraph{Compilador.} El compilador es específico a cada microcontrolador para el cual se desea programar. En este caso corresponde al compilador Microchip XC16 en su versión 1.1, adecuado para la familia de microcontroladores PIC24.

\paragraph{Programador.} El programador utilizado en este caso corresponde al Microchip ICD3, adecuado para ambientes de producción.

\paragraph{Tarjeta de desarrollo}. La tarjeta de desarrollo permite realizar las pruebas sobre el sistema embebido funcionando y es fundamental para el desarrollo de la aplicación del sistema embebido debido a que la aplicación que se desarrolla no se puede ejecutar en el mismo computador, sino que en el sistema objetivo que corresponda. En este caso se utiliza la plataforma de desarrollo que provee el Cubesat Kit de Pumpkins\cite{CUBESAT_DB}. Esta tarjeta de desarrollo permite montar un módulo de procesador con un PIC24F256GA110\cite{PIC24FJ256GA110} y un bus PC104 al cual se conectan todos los componentes del satélite. Cuenta además con un slot de memoria SD, un reloj de tiempo real y un conversor RS232 a USB para fines de \textit{debug} (ver figura \ref{img:ch4:cubesat_db}. La tarjeta de desarrollo es eléctricamente idéntica al la placa madre que se utilizará en el satélite por lo tanto es la herramienta adecuada para realizar todo el trabajo de desarrollo y pruebas del sistema. Se debe hacer hincapié en lo fundamental de esta herramienta en el proceso de desarrollo de un sistema embebido debido a que: la aplicación compilada es específica para el dispositivo objetivo; las herramientas de simulación de microcontroladores no son suficientes para testear las reales condiciones de ejecución de la aplicación; y porque el ciclo de desarrollo se completa con la resolución y ajuste de problemas observados durante la ejecución de la aplicación en su sistema objetivo y de manera dinámica como resultado de respuestas a entradas no deterministas.

\figura{img/cubesat_db.jpg}{scale=0.5}{Tarjeta de desarrollo para Cubesat Kit de Pumpkins}{img:ch4:cubesat_db}{!h}

\section{Organización del proyecto}

\subsection{Directorios}
Con el objetivo de mantener un orden lógico a lo largo del desarrollo del software se debe dar una estructura lógica a los diferentes archivos fuentes que lo componen. Así se organiza un árbol de directorio que permita encontrar de manera sencilla cada archivo fuente según su función en el sistema. La organización de los directorios sigue la arquitectura de capas a nivel global de la aplicación quedando de la siguiente manera
\begin{verbatim}
	  +-main/
	  |
	  +-Drivers/
	  | |
	  | +-include/
	  |
	  +-<RTOS>/
	  |
	  +-Payloads/
	  | |
	  | +-Cmd/
	  | | |
	  | | +-include/
	  | | 
	  | +-Drivers/
	  |   |
	  |   +-include/
	  | 
	  +-<Proyecto>.X/
	  |
	  +-System/
	  | |
	  | +-include/
	  |
	  |_main.c
\end{verbatim}

Los desarrollos deben seguir esta estructura al momento de agregar archivo con código fuente al sistema. En la tabla \ref{ch4:table:directory} se detalla la funcionalidad de cada directorio.

\begin{table}[ht!] \caption{Organización de directorios del proyecto}
\centering
\begin{tabularx}{\textwidth}{lX}\hline
\textbf{Directorio} & \textbf{Descripción}\\\hline
\texttt{main} & Directorio principal, contiene el archivo main.c y archivos de configuración globales\\
\texttt{include} & Dentro de cada directorio de fuentes, se agrega un directorio \textit{include} que contiene las cabeceras de cada archivo fuente en el nivel superior.\\
\texttt{Drivers} & Contiene las fuentes para los drivers del sistema como el computador a bordo, el sistema de comunicaciones y el sistema de energía.\\
\texttt{<RTOS>} & Carpeta con el nombre del sistema operativo. Contiene los archivos fuentes, cabeceras y librerías del sistema operativo según su organización particular.\\
\texttt{Payloads} & Comandos y drivers relacionados con \textit{payloads}. Se encuentra en un directorio aparte pues acá se concentrarán la mayoría del software específico de la misión.\\
\texttt{Payloads/Cmd} & Implementación de comandos del sistema relacionados con \textit{payloads}.\\
\texttt{Payloads/Drivers} & Implementación de drivers relacionados con \textit{payloads}.\\
\texttt{<Proyecto>.X} & Directorio con la configuración del proyecto generado por el IDE MPLABX.\\
\texttt{System} & Archivos con las fuentes del sistema base, incluye implementación de comandos, repositorios y tareas.\\
\hline
\end{tabularx} \label{ch4:table:directory}
\end{table}

\subsection{IDE}
Esta estructura de directorios creada es la base para configurar adecuadamente los archivos con las fuentes del proyecto en el IDE, en este caso MPLAB X. Para la correcta construcción de software en el IDE se deben ajustar las configuraciones del compilador según las indicaciones de la tabla \ref{ch4:table:xc16:configuracion} (parámetros no mencionados mantienen su configuración por defecto):

\begin{table}[ht!] \caption{Configuración del compilador XC16}
\centering
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{3cm} >{\raggedright}p{5cm} X}\hline
\multicolumn{3}{c}{\textbf{XC16}}\\\hline
\multicolumn{3}{c}{\textbf{xc16-gcc}}\\\hline

\multicolumn{3}{c}{\textbf{Categoría: Memory Model}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Code model & Large & El tamaño de la aplicación supera el espacio de memoria cercano.\\
Data model & Large & El tamaño de la aplicación supera el espacio de memoria cercano.\\
Scalar model & Large & El tamaño de la aplicación supera el espacio de memoria cercano.\\
Location of constant model & Code space & \\
\hline

\multicolumn{3}{c}{\textbf{Categoría: Optimizations}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Optimization level & 0 & Las optimizaciones pueden introducir cambios en la forma de ejecución del código, por ejemplo, evitar ciclos \texttt{for} o \textit{while} que realizan \textit{busy waitings}.\\
\hline

\multicolumn{3}{c}{\textbf{Categoria: Preprocessing and messages}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
C include dirs & \texttt{..; ../Drivers/include; ../System/include; ../<RTOS>/<include>; ../Payloads/Cmd/include; ../Payloads/Drivers/include} & Configura los directorios donde el IDE busca las cabeceras para poder incluirlas solo por su nombre y activar el auto completado.\\
Additional warnings & Seleccionada & Permite un nivel mayor de advertencias en tiempo de compilación\\
\hline

\end{tabularx} \label{ch4:table:xc16:configuracion}
\end{table}

Ejemplos del dialogo para configurar las opciones del compilador en MPLAB X se detallan en la figura \ref{ch4:xc16:config}.

%···················· FIGURE ····················
\begin{figure}[ht!] \centering
\subfloat[]{\includegraphics[width=0.48\textwidth]{img/xc16_config_mem.png}}
% \subfloat[]{\includegraphics[width=0.3\textwidth]{img/xc16_config_opt.psng}}
\hspace{0.3cm}
\subfloat[]{\includegraphics[width=0.48\textwidth]{img/xc16_config_prep.png}}
\caption{Diálogo de configuración del compilador XC16 en MPLABX}\label{ch4:xc16:config}
\end{figure}
%················································

\subsection{Documentación}
%TODO: Doxygen

\section{Controladores de hardware}
La primera capa de la aplicación corresponde a una serie de módulos que implementan los controladores de hardware. En este caso un módulo significa una librería que consiste en una serie de funciones escritas en lenguaje C las cuales acceden a funcionalidades específica de cierto hardware respetando sus protocolos o API. La librería consta entonces de su correspondiente archivo fuente con extensión \texttt{.c} y un archivo de cabecera con extensión \texttt{.h} que contiene la declaración de las funciones.

La hoja de datos de cada dispositivo de hardware entrega la información necesaria para poder configurarlo y acceder a sus funciones. Se puede requerir de diferentes niveles de abstracción a la hora de implementar el controlador:
\begin{enumerate}
    \item Programar en lenguaje ensamblador (\textit{assembler}). Se maneja directamente el juego de instrucciones del procesador (también conocido como lenguaje máquina) para configurar sus registros, manejar periféricos o ejecutar un programa general. Requiere de un compilador de \textit{assembler} para generar el ejecutable binario.
    \item Utilizar un compilador en C. El compilador provee un nivel mayor de abstracción al permitir programar en un lenguaje de alto nivel y portable como C. Además provee librerías básicas para las funciones específicas de cada dispositivo.
    \item Utilizar una librería externa. Un controlador de hardware puede requerir los servicios de otro controlador para su funcionamiento. Es el caso típico de dispositivos que utilizan algún protocolo de comunicación (RS232, SPI, I2C) y su controlador consiste en implementar una API de llamadas sobre este protocolo.
\end{enumerate}

En este caso se hará un uso extensivo de las librerías escritas en C que provee el compilador XC16 para construir drivers más complejos a través de sus funciones base. Lo principal es implementar los drivers de cada periféricos disponible en el microcontrolador pues serán los recursos que utilizarán los dispositivos externos que completan el sistema del satélite.

\subsection{Microcontrolador}

\subsection{Periféricos}
En la sección \ref{ch2:embedded:perif} se revisaron los periféricos disponibles en el PIC24F256GA110 en la tabla \ref{ch4:table:perif:list} se detalla la lista de drivers a implementar y la arquitectura que se utilizará en cada uno de ellos.

\begin{table}[ht!] \caption{Drivers para periféricos del microcontrolador}
\centering
\begin{tabular}{ll}\hline
\textbf{Periférico} & \textbf{Arquitectura} \\
Timers & \\
PWM & \\
I2C & \\
SPI & \\
UART & \\
Input Capture & \\
RTCC & \\
CRC & \\
Comparadores & \\
ADC & \\
\\hline
\end{tabular} \label{ch4:table:hardware_req}
\end{table}

\subsubsection{Implementación de un controlador síncrono}

\subsubsection{Implementación de un controlador asíncrono}

\section{Sistema operativo}
En la capa de sistema operativo se ha optado por utilizar FreeRTOS. Este sistema operativo está diseñado específicamente para sistema embebidos y provee la capacidad de implementar tareas que son módulos de software que funciona de manera concurrente y puede compartir información a través de diferentes estructuras de sincronización. FreeRTOS soporta una gran variedad de microcontroladores, entre los cuales se encuentra la familia PIC24F, a través de \textit{ports} y aplicaciones demo que se obtienen al descargar el software. FreeRTOS consiste básicamente de 5 archivos fuentes en lenguaje C (sólo tres son necesarios para la utilidad básica), 11 archivos de cabecera y una capa portable dependiente del dispositivo sobre el cual se trabaja. Fuera de los demos y diferentes ports incluidos con la descarga el siguiente árbol de directorio se agrega a la carpeta del proyecto y en la configuración del proyecto en MPLABX:

\begin{verbatim}
FreeRTOS/Source/tasks.c
FreeRTOS/Source/queue.c
FreeRTOS/Source/list.c
FreeRTOS/Source/portable/[compiler]/[architecture]/port.c
FreeRTOS/Source/portable/[compiler]/[architecture]/portasm_[architecture].S
FreeRTOS/Source/portable/MemMang/heap_2.c
FreeRTOS/Source/include
FreeRTOS/Source/portable/[compiler]/[architecture]
\end{verbatim}

Se requieren algunas configuraciones extra en el compilador para el correcto funcionamiento de FreeRTOS, como se detalla en la tabla \ref{ch4:table:xc16:configuracion:freertos}

\begin{table}[ht!] \caption{Configuración del compilador XC16 para FreeRTOS}
\centering
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{3cm} >{\raggedright}p{5cm} X}\hline
\multicolumn{3}{c}{\textbf{XC16}}\\\hline

\multicolumn{3}{c}{\textbf{xc16-gcc}}\\%\hline
\multicolumn{3}{c}{\textbf{Categoría: Optimizations}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Omit frame pointer & Seleccionada & Ver documentación de FreeRTOS.\\
\hline
\multicolumn{3}{c}{\textbf{Categoría: Preprocessing and messages}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Define C macros & \texttt{MPLAB\_PIC24\_PORT} & Ver documentación de FreeRTOS.\\
\hline

\multicolumn{3}{c}{\textbf{xc16-as}}\\%\hline
\multicolumn{3}{c}{\textbf{Categoría: General Options}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
ASM include dirs & \texttt{../FreeRTOS/Source/portable/ MPLAB/PIC24\_dsPIC/} & Funciones \textit{assembler} específicas de la arquitectura.\\
\hline

\end{tabularx} \label{ch4:table:xc16:configuracion:freertos}
\end{table}

El primer paso para integrar el sistema operativo es crear el archivo de cabecera con su configuración llamado \texttt{FreeRTOSConfig.h}. El archivo se compone de una serie de 	\textit{defines} que cambian el comportamiento del sistema operativo y lo ajustan a las necesidades de la aplicación. Una plantilla con los posibles valores a configurar se encuentra en la página web de FreeRTOS: \url{http://www.freertos.org/a00110.html}. Un ejemplo de este archivo se detalla en el código \ref{ch4:code:FreeRTOSConfig.h}

\begin{lstlisting}[float,label=ch4:code:FreeRTOSConfig.h, caption=FreeRTOSConfig.h]
#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

#include <xc16.h>

#define configUSE_PREEMPTION			1
#define configUSE_IDLE_HOOK				1
#define configUSE_TICK_HOOK				0
#define configTICK_RATE_HZ				250
#define configCPU_CLOCK_HZ				16000000
#define configMAX_PRIORITIES			4
#define configMINIMAL_STACK_SIZE		115
#define configTOTAL_HEAP_SIZE			5120
#define configMAX_TASK_NAME_LEN			8
#define configUSE_TRACE_FACILITY		0
#define configUSE_16_BIT_TICKS			1
#define configIDLE_SHOULD_YIELD			1

#define INCLUDE_vTaskPrioritySet		1
#define INCLUDE_uxTaskPriorityGet		0
#define INCLUDE_vTaskDelete				0
#define INCLUDE_vTaskSuspend			1
#define INCLUDE_vTaskDelayUntil			1
#define INCLUDE_vTaskDelay				1

#define configKERNEL_INTERRUPT_PRIORITY	0x01

#endif /* FREERTOS_CONFIG_H */
\end{lstlisting}

En segundo lugar se deben crear las tareas que ejecutará el sistema. En FreeRTOS una tarea es una función con una firma específica y que por lo general entrará en un ciclo de permanente para mantener su ejecución en el tiempo. Toda tarea debe poseer la siguiente firma: \texttt{void taskName(void *)}, donde el nombre de la función varia de tarea en tarea, pero siempre debe retornar \textit{void} y recibir un puntero \textit{void} como parámetro. Un simple prototipo de tarea en FreeRTOS se detalla en el código \ref{ch4:code:taskTest}. La tarea se denomina \texttt{taskTest} y recibe a través de su parámetro una cadena de texto. La tarea entra en un ciclo e imprime de manera periódica el \textit{string} entregado como parámetro. Aunque la tarea está en un ciclo infinito, no se encuentra en una situación de \textit{busy waiting} dado que utiliza la función \texttt{vtaskDelay} que detiene la ejecución de la tarea durante un periodo de tiempo liberando los recursos del procesador; en este caso se dice que la tarea se encuentra dormida.

\begin{lstlisting}[float,label=ch4:code:taskTest,caption=taskTest.c]
#include taskTest.h

void taskTest(void *param)
{
    const unsigned long Delayms = 500 / portTICK_RATE_MS;
    char *msg = (char *)param;

    while(1)
    {
        vTaskDelay(Delayms);
        printf("[taskTest] %s\n", msg);
    }
}
\end{lstlisting}

Una vez programada la función que corresponde a la tarea, se puede configurar el sistema para que la ejecute. Esto se realiza en el archivo \texttt{main.c} donde se realizan las configuraciones del hardware, ser cargan las configuraciones del sistema operativo contenida en el archivo \texttt{FreeRTOSConfig.h}, se crean las tareas y se inicia el sistema operativo. Para crear tareas se utiliza la función \texttt{xTaskCreate} indicando la función a ejecutar, un nombre, prioridad, memoria asignada y parámetros; para detalles referirse a la documentación de FreeRTOS\cite{FREERTOS_API}. El sistema operativo se inicia con la función \texttt{vTaskStartScheduler()} y una vez alcanzado este punto, el control de los procesos a ejecutar queda en manos de FreeRTOS quien según su algoritmo de \texttt{scheduling} seleccionará la tarea que debe ejecutarse en cada instante. El llamado a la función \texttt{vTaskStartScheduler} no retorna a menos que se produzca un error en la ejecución del sistema operativo. El el código \ref{ch4:code:test:main.c} se ilustra la forma de iniciar FreeRTOS con dos tareas ejecutándose de manera simultanea, para mantener la generalidad no se incluyen configuraciones de hardware específicas.

\begin{lstlisting}[float,label=ch4:code:test:main.c,caption=main.c]
/* RTOS Includes */
#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"
#include "task.h"

/* Task includes */
#include "taskTest.h"

int main(void)
{
    /* Crating all task */
    xTaskCreate(taskTest, (signed char*)"taskTest", configMINIMAL_STACK_SIZE, (void *)"T1 Running...", 1, NULL);
    xTaskCreate(taskTest, (signed char*)"taskTest", configMINIMAL_STACK_SIZE, (void *)"T2 Running...", 2, NULL);

    /* Start the scheduler. Should never return */
    printf(">>Starting FreeRTOS\n");
    vTaskStartScheduler();
    
    /* Never get here */
    return 0;
}
\end{lstlisting}

El resultado de ejecutar el programa anterior se puede visualizar a través de la consola serial conectada al sistema objetivo:
\begin{verbatim}
>>Starting FreeRTOS scheduler [->]
[taskTest] T2 Running...
[taskTest] T1 Running...
[taskTest] T2 Running...
[taskTest] T1 Running...
[taskTest] T2 Running...
\end{verbatim}

Se observa que la tarea de mayor prioridad es la primera en ejecutarse y por lo tanto imprime su mensaje en pantalla: \texttt{[taskTest] T2 Running...}. Esta tarea ahora pasa a estado suspendido y por lo tanto la siguiente tarea en orden de prioridad tiene acceso al procesador para ejecutarse, imprimir su mensaje: \texttt{[taskTest] T1 Running...} y pasar a estado suspendido. Cuando ninguna tarea está disponible para ejecutarse FreeRTOS ejecuta la tarea \texttt{Idle} iniciada por defecto por el sistema operativo. Luego de 500[ms] la tarea de mayor prioridad despierta y toma el control del procesador repitiendo el ciclo anterior.

Con esto concluye la integración del sistema operativo en el software de vuelo y se demuestra el correcto funcionamiento de FreeRTOS. Ahora se cuenta con una nivel mayor de abstracción en la aplicación donde el sistema operativo tiene el control sobre los procesos que se ejecutan en el microcontrolador y la aplicación final se implementa en las diferentes tareas que se crean.

%TODO: Hablar de la configuracion de memoria
%TODO: Hablar de la configuracion de prioridades

\section{Aplicación}
En la capa de aplicación se debe implementar la arquitectura de software detallada en la figura \ref{img:ch3:dis:arch} que permite el cumplimiento de todos los requerimientos de operacionales del satélite. El proceso incluye interpretar el patrón de diseño que inspira la arquitectura base para ser implementado en un lenguaje \textit{procedural} como C. Conviene también implementar la arquitectura base del patrón de ejecutador de comandos para contar con un sistema base que sea general y bien probado sobre el cual implementar las funcionalidades específicas del proyecto. Las funciones específicas de un proyecto satelital estarán implementadas en la capa de \textit{listeners} y la lista de comandos por lo que finalmente se detalla la implementación de los distintos módulos que competan los requerimientos del proyecto SUCHAI en específico.

\subsection{Implementación del patrón de diseño}
Cómo se describe en la sección \ref{ch2:sec:214} se debe implementar un patrón de diseño, específicamente \textit{Command Pattern} en un lenguaje procedural como C. El problema radica en la programación basada en patrones de diseño es una técnica utilizada principalmente en lenguajes de programación orientados a objetos y los patrones se describen según diagramas de colaboración entre objetos incluyendo técnicas como herencia o polimorfismo. No obstante el diseño de una arquitectura de software debería ser independiente del lenguaje de programación a utilizar, así como también, el diseño de la arquitectura basándose en patrones\cite{SYSTEM_PATTERNS}. Para sortear esta situación se procede a definir cómo se traduce cada elemento del patrón de diseño deseado a la plataforma objetivo.

\begin{itemize}
    \item \textbf{Controladores o clientes:} Corresponderán a tareas del sistema operativo. Pueden ser tareas que se ejecuten de manera periódica o basadas en eventos. Los clientes estarán ejecutándose constantemente y según la inteligencia que tengan programada pueden responder a algún evento periódico o un estímulo externo para generar comandos al sistema. Cada tarea posee su propio \texttt{stack} de memoria y se pueden comunicar con otras o utilizar recursos compartidos del sistema a través de estructuras de sincronización.
    
    \item \textbf{Procesador de comandos o despachador:} Corresponde a una tarea del sistema operativo cuyo funcionamiento está basado en evento, en específico, el arribo de un comando.
    
    \item \textbf{Ejecutador:} El ejecutador también es una tarea del sistema operativo que se encarga de realizar la llamada del comando, es decir, ejecutar la función. Su funcionamiento es basado en eventos según la llegada de un comando.
    
    \item \textbf{Transferencia de comandos:} La transferencia de comandos se realiza a través de una cola de FreeRTOS, que es una estructura de sincronización que permite el intercambios de mensajes en un esquema productor-consumidor.
    
	\item \textbf{Comandos:} Los comandos están representados por un nuevo tipo definido en C. Este tipo hace referencia a una función con una firma específica. Siempre que una función cumpla la firma específica en el tipo definido podrá ser considerada un comando y ser ejecutada como tal. Para encapsular parámetros importante de un comando, que en el caso original serían variables de estado de un objeto, se crea una estructura en C.
    
    \item \textbf{Repositorios:} Los repositorios y proveedores de servicios se implementaran como librerías que acceden a funciones a las capas inferiores del sistema como drivers a submódulos o dispositivos de entrada y salida.
\end{itemize}

\subsection{Comandos}
Los comandos se han implementado como funciones que deben respetar una firma específica que se convierte en un un nuevo tipo de dato. En este caso la función debe retornar un entero y recibir un parámetro, como se detalla en el código \ref{ch4:code:cmdFunction}, lo que define dos aspectos fundamentales del software:
\begin{itemize}
    \item Todo comando debe retornar un valor que puede tomar un significado dentro de la aplicación, en este caso, se define que el comando ha terminado su ejecución de manera insatisfactoria si retorna un valor cero o bien un valor no cero para indicar un éxito en la operación; con esa convención se hace natural utilizar el llamado a las funciones dentro de una sentencia condicional que utilice directamente el valor retornado como condición. 
    
    \item Por otro lado los comandos reciben un sólo parámetro, en principio de cualquier tipo, a través de un puntero de tipo \texttt{void}. Esto tiene una serie de consecuencias: por un lado se hace flexible la llamada a la función ya que diferentes comandos podrían recibir diferentes tipos de datos siempre que se dereferencien adecuadamente; también hace eficiente la llamada a la función pues no se requiere realizar una copia del parámetro en la llamada ya que pasan por referencia; la desventaja es natural al uso de punteros, pues este debe seguir siendo válido durante la ejecución del comando para evitar dereferenciar un puntero nulo o corromper algún sector de memoria.
\end{itemize}

\begin{lstlisting}[float,label=ch4:code:cmdFunction,caption=Prototipo de un comando]
/**
 *  Defines the prototype that every command must conform
 */
typedef int (*cmdFunction)( void * );
\end{lstlisting}

Para encapsular la información asociada a los comandos se crea una nueva estructura de datos definida como en el código \ref{ch4:code:ExeCmd} que representa a un comando que es entregado al módulo \textit{executer}. La estructura contiene dos campos: el puntero a la función que implementa el comando según la definición del código \ref{ch4:code:cmdFunction}; y el parámetro del comando.

\begin{lstlisting}[float,label=ch4:code:ExeCmd,caption=Estructura de comandos para \textit{executer}]
/**
 * Structure that represents a command passed to executer. Contains a 
 * pointer of type cmdFunction with the function to execute and one 
 * parameter for that function
 */
typedef struct exec_command{
    int param;                  ///< Command parameter
    cmdFunction fnct;           ///< Command function
}ExeCmd;
\end{lstlisting}

Con el objetivo de implementar una estrategia simple y flexible que permita tanto generar comandos así como determinar la función que se asocia a cada comandos se ha definidos una nueva estructura de datos que representa a los comandos que son generados por los \textit{listeners} cuya definición se detalla en el código \ref{ch4:code:DispCmd}. Si se utiliza la estructura definida en el código \ref{ch4:code:ExeCmd} significa que cada \textit{listener} debe conocer todos los comandos disponibles en el sistema y cada vez que se requiere generar un comando se debe agregar a mano la función que corresponde en la estructura. Esto genera inconvenientes ya que al separar la definición de cada comando archivos diferentes se debe realizar una serie de \textit{includes}, también hace poco automatizado la generación de comandos en serie y no es una forma práctica de generar comandos de manera remota.

Por esta razón los comandos serán representados a través de un código numérico único, delegando al repositorio de comandos la responsabilidad de mapear entre los códigos y la función asociada. La estructura de datos que representa a los comandos que son enviados desde los \textit{listeners} al \textit{dispatcher} contiene además ciertos meta datos que permiten al \textit{dispatcher} tomar decisiones sobre la ejecución de un comando basado en esta información extra. Dos campos de información son especialmente relevantes:

\begin{itemize}
    \item \textbf{Origen del comando:} este campo contiene un código numérico que identifica el módulo que ha generado el comando, esto permite implementar el filtrado de comandos desde cierto módulo cuando, por ejemplo, no esté funcionando correctamente.
    
    \item \textbf{Requerimiento de energía:} este campo indica el nivel de energía que requiere el comando para ejecutarse, así se pueden filtrar comandos que requieran mayor energía de la disponible en el sistema.
\end{itemize}

\begin{lstlisting}[float,label=ch4:code:DispCmd,caption=Estructura de comandos para \textit{dispatcher}]
/**
 * Structure that represent a command passed to dispatcher. Contains 
 * only a code that represent the function to call, a paremeter and 
 * other command's metadata
 */
typedef struct ctrl_command{
    int cmdId;		///< Command id, represent the desired command
    int param;		///< Command parameter
    int idOrig;     ///< Metadata: Id of sender subsystem
    int sysReq;     ///< Metadata: Level of energy the command requires
}DispCmd;
\end{lstlisting}

Todas estas definiciones son incluidas en un archivo de cabecera denominado \texttt{cmdIncludes.h} que homogeneiza el tratamiento de los comandos a lo largo de la aplicación.

La implementación de un comando en específico requiere la definición de una función que cumpla con la firma definida en el código \ref{ch4:code:cmdFunction}, un ejemplo es el código \ref{ch4:code:get_rtos_memory} donde se implementa el comando \texttt{get\_rtos\_memory}; notar que este comando forma parte del archivo \texttt{cmdOBC.c}, por lo tanto cada función y definición incluye el prefijo \texttt{obc\_} como parte del estándar de código utilizado en el proyecto. Este comando que será utilizado como ejemplo es, sin embargo, una importante funcionalidad dentro del software de vuelo que nos permitirá obtener información sobre el uso de memoria del sistema operativo. El objetivo es utilizar la función \texttt{xPortGetFreeHeapSize} de FreeRTOS que entrega la cantidad de memoria en \textit{bytes} disponible en el \textit{heap}\cite{FREERTOS_API} y desplegarla en consola. La convención indica que retornar un valor cero desde el comando significa error lo cual demuestra su conveniencia en este caso pues el comando puede retornar directamente la cantidad de memoria disponible.

\begin{lstlisting}[float,label=ch4:code:get_rtos_memory,caption=Ejemplo de comando]
/**
 * Performs debug taks over current RTOS. Get rtos memory usage in bytes
 *
 * @param param Not used
 * @return Availible heap memory in bytes
 */
int obc_get_rtos_memory(void *param)
{
    size_t mem_heap = xPortGetFreeHeapSize();
    printf("Free RTOS memory: %d", mem_heap);

    return mem_heap;
}
\end{lstlisting}

Además de la implementación de la función se debe generar un método de registro del comando para que esté disponible en el sistema y sea reconocido por el repositorio de comandos. Este proceso es fundamental para permitir la modificabilidad del sistema de vuelo extendiéndolo a través de nuevos comandos, por lo cual se exploraron una serie de alternativas en pos de lograr el método más directo, transparente y de menor impacto en el código del proyecto:

\begin{enumerate}
    \item Un arreglo único de comandos centralizado en el repositorio de comandos. Se llena manualmente un arreglo de punteros a funciones tipo \textit{cmdFunction} y para registrar un nuevo comando se agrega dentro del arreglo.
    \begin{itemize}
        \item \textbf{Ventajas:} Se puede ahorrar memoria RAM creando un arreglo de tipo \textit{const} que se almacena en memoria de programa.
        \item \textbf{Desventajas:} Complejo seguir cambios en el orden en que se registran los comandos y por lo tanto su código asociado. Ofrece pocas posibilidades de agrupar comandos según funciones. Alto impacto al agregar un nuevo comando pues implica la modificación de múltiples archivos fuente, incluyendo el repositorio de comandos.
    \end{itemize}
    
    \item Varios arreglos con comandos centralizados en el repositorio de comandos. Se agrupan comandos con funcionalidades relacionadas en varios arreglos, así cuando se agrega un nuevo comando sólo se modifica el arreglo relacionado a una determinada serie de comandos.
    \begin{itemize}
        \item \textbf{Ventajas:} Mejor agrupación de los comandos, localizando cambios. Los códigos numéricos se pueden diferenciar por grupo.
        \item \textbf{Desventajas:} Agregar un comando requiere modificar varios archivos, incluyendo el archivo donde se implementa y el repositorio de comandos.
    \end{itemize}
        
    \item Descentralizar cada arreglo de comandos en el archivo correspondiente. Cada archivo que implementa un grupo de comandos cuenta con un arreglo con las funciones. El repositorio de comandos utiliza este arreglo como una variable externa.
    \begin{itemize}
        \item \textbf{Ventajas:} Mejor agrupación de comandos. Bajo impacto en el código al agregar un comando, pues sólo se modifica el archivo dónde se encuentra el comando sin intervenir el repositorio de datos.
        \item \textbf{Desventajas:} Se dificulta el seguimiento de cambios en los códigos de cada comando. Agregar un nuevo grupo de comandos, en un nuevo archivo, requiere modificaciones de código en el repositorio de comandos.
    \end{itemize}
    
    \item Descentralizar comandos y utilizar \texttt{enums} para asignar códigos. Similar a la alternativa anterior pero los códigos de cada comando y la forma de llenar los arreglos de comandos se basan en una estructura de enumeración de C que abstrae el uso de códigos numéricos por sentencias textuales.
    \begin{itemize}
        \item \textbf{Ventjas:} Agregar un comando sólo requiere cambios locales al archivo que agrupa un determinado tipo de comandos. Se facilita el seguimiento de cambios en los comandos disponibles pues los la definición textual de la enumeración no cambia.
        
        \item \textbf{Desventajas:} Aún se requiere modificar el repositorio de comando cuando se agrega un archivo con un nuevo grupo de funciones. Al completar los arreglos de funciones a través de las enumeraciones no se puede crear un arreglo a mano en memoria de datos, se requiere una función que inicialice los arreglos cada vez que se inicia el sistema.
    \end{itemize}
\end{enumerate}

Todas las estrategias mencionadas fueron implementadas en algún momento, sin embargo, la cuarta alternativa ha demostrado ser la opción más flexible y conveniente. De este modo el proceso de registro del comando creado sólo requiere modificaciones en los archivos relacionados a su implementación, en este caso \texttt{cmdOBC.c} y \texttt{cmdOBC.h}. 

Cada archivo con un grupo de comandos debe tener una estructura de enumeración (\texttt{enum} en C) que representan los códigos de cada comando. El primer valor de la enumeración debe ser diferente para cada grupo de comandos para no generar ambigüedades y para agrupar los comandos también por códigos. El último valor de la enumeración es un valor \textit{dummy} que sólo es utilizado para controlar el tamaño del arreglo de comandos. Luego, por cada función que implemente un comando se agrega un valor en la enumeración, como en el código \ref{ch4:code:OBC_CmdIndx}.

\begin{lstlisting}[float,label=ch4:code:OBC_CmdIndx,caption=Lista de comandos disponibles]
/**
 * List of availible commands
 */
typedef enum{
    obc_id_reset = 0x1000,  ///< @cmd_first
    obc_id_get_rtos_memory, ///< @cmd
        
    ppc_id_last_one    // Dummy element
}OBC_CmdIndx;
\end{lstlisting}

En este caso se registran dos comandos, \texttt{obc\_reset} y \texttt{obc\_get\_rtos\_memory}, la convención de sintaxis utilizada indica que se debe utilizar el prefijo del grupo de comandos \texttt{obc\_} y un prefijo que indique que se trata de un código de comando \texttt{id\_}. El código \ref{ch4:code:OBC_CmdIndx} también muestra como se utiliza Doxygen para mantener en la documentación del proyecto una lista actualizada con el valor de cada enumeración que permita de manera directa asociar el código de un comando cuando estos se generen de manera remota.

También en el archivo \texttt{cmdOBC.c} se debe crear el arreglo que contiene la lista de funciones, en este caso denominado \texttt{obc\_Function} cuyo tamaño se determina a través del último elemento de la enumeración. Esta lista debe ser inicializada a través de una función que se ejecutará al inicio del sistema, en este caso se denomina \texttt{obc\_onResetCmdOBC}. El código \ref{ch4:code:obc_onResetCmdOBC} detalla este proceso.

\begin{lstlisting}[float,label=ch4:code:obc_onResetCmdOBC,caption=Registro de comandos]
cmdFunction obc_Function[OBC_NCMD];

/**
 * This function registers the list of command in the system, 
 * initializing the functions array. This function must be called
 * at every system start up.
 */
void obc_onResetCmdOBC(void)
{
    obc_Function[(unsigned char)obc_id_reset] = obc_reset;    
    obc_Function[(unsigned char)obc_id_get_rtos_memory] = obc_get_rtos_memory;
}
\end{lstlisting}
