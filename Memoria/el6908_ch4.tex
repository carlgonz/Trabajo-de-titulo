\chapter{Implementación}

En este se describe el proceso de implementar la arquitectura para el software de vuelo de un nano-satélite diseñada en el capítulo \ref{ch3}. El proceso de implementación se concentrará en completar los requerimientos mínimos del sistema para alcanzar cierta generalidad que convierta al presente trabajo en la base de futuras misiones satelitales. En este sentido se evitará la discusión de detalles de implementación específicos de la misión del proyecto SUCHAI, para lo cual se puede tomar como referencia el trabajo desarrollado en torno al diseño e integración del proyecto\cite{TOOPAZO}. En la misma línea, al presentar en primer lugar la implementación del núcleo de la aplicación como base de la característica de reusabilidad, se demuestra la capacidad de modificabilidad del sistema al agregar de manera incremental nuevas funcionalidades que completen los requerimientos esperados.

El proceso de implementación consta de tres etapas principales, que se alinean con la visión global del sistema en forma de arquitectura de tres capas. En primer lugar se detallan los drivers que se requieren implementar para esta plataforma de hardware específico, definiendo el tipo de arquitectura utilizada en el driver para guiar la implementación. En segundo lugar se detalla la forma de integrar el sistema operativo preparando al sistema para montar la aplicación final. Y por último la aplicación final se implementará módulo a módulo hasta lograr un sistema funcional.

\section{Ambiente de desarrollo}
La implementación del proyecto comienza por la definición del entorno y herramientas de desarrollo disponibles, pues son elementos esenciales que definen las posibilidades, limitaciones y marco de trabajo durante todo el proceso. El ambiente de desarrollo incluye los siguientes elementos: computadores, sistema operativo, control de versiones, el ambiente de desarrollo integrado o IDE, compilador, programador del microcontrolador y tarjeta de desarrollo.

\paragraph{Computadores.} En general para el desarrollo de software no se tienen requerimientos de hardware elevados, considerando que bastaría con ejecutar un procesador de texto, una aplicación de linea de comandos para ejecutar el compilar y la disponibilidad de al menos un puerto USB para utilizar el programador del microcontrolador. La aplicación más demandante en recursos es el IDE (ver \ref{ch4:para:ide}) cuyos requerimientos recomendados de hardware se encuentran en la tabla \ref{ch4:table:hardware_req}.

\begin{table}[ht!] \caption{Requerimientos de hardware recomendados para desarrollo}
\centering
\begin{tabular}{ll}\hline
\textbf{Procesador} & Intel Pentium 4 @ 2.6 GHz o equivalente\\
\textbf{Memoria RAM} & 2 GB\\
\textbf{Espacio en disco} & 1 GB\\\hline
\end{tabular} \label{ch4:table:hardware_req}
\end{table}

\paragraph{Sistema Operativo.} En principio no existen restricciones sobre el sistema operativo a utilizar dado que las principales herramientas como el IDE y el compilador son multiplataforma. Sin embargo el presente trabajo se ha desarrollado sobre plataformas GNU/Linux por su flexibilidad, libertad de distribución, disponibilidad de herramientas y estabilidad. Las principales distribuciones de Linux utilizadas fueron Kubuntu 12.04 LTS amd64 y LinuxMint 14 amd64.

\paragraph{Control de versiones.} Un sistema adecuado de control de cambios es fundamental en el desarrollo de un proyecto de software, incluso para el desarrollo de software de sistemas embebidos. Un sistema de control de versiones permite no sólo mantener un registro de los cambios incrementales del código, si no también revertir estos cambios, abrir ramas paralelas de desarrollo y el trabajo colaborativo entre un equipo de programadores. En este proyecto se utilizó el software Subversion con un servidor propio dedicado netamente a proveer el servicio de almacenamiento remoto del código junto al control de versiones. Subversion permite mantener un repositorio remoto y hacer copias de trabajo locales en el equipo de cada desarrollador (\textit{chekout}). Los programadores realizan cambios sobre el código y suben las modificaciones al servidor como una nueva versión (\textit{commit}), estos cambios se ven reflejados cuando el resto del equipo sincroniza sus copias de trabajo con el servidor remoto (\textit{update}). Existe una amplia gama de software de control de versiones, en particular se recomienda el uso de Git que posee como principal característica ser un sistema distribuido donde cada copia local actúa como un repositorio en si mismo haciéndolo más robusto. Si no se cuenta con servidores propios, se pueden utilizar servicio de almacenamiento de repositorios en línea, como GitHub, que se integra con Git y es gratuito para repositorios públicos.

\paragraph{IDE.}\label{ch4:para:ide} El ambiente de desarrollo integrado o IDE es la aplicación fundamental del proceso, un buen ambiente de desarrollo proveerá las herramientas adecuadas para el desarrollo organizado y consistente del software integrando el editor de texto, servicio de control de versiones, integración con el compilador, integración con el programador, sistema de \textit{debug}, sistema de documentación entre otros. En el caso de este proyecto se utiliza el entorno de desarrollo integrado de Microchip MPLAB X que se caracteriza por ser un entorno multiplataforma, basado en el proyecto de código libre NetBeans. Este IDE integra un avanzado editor de texto, con funcionalidades de control de cambios locales, múltiples configuraciones para un mismo proyecto, integración con múltiples compiladores y acceso directo a la programación del dispositivo todo desde la misma aplicación centralizando todo el proceso de desarrollo en un ambiente adecuado.

\figura{img/mplabx.png}{width=\textwidth}{Entorno de desarrollo integrado MPLABX}{img:ch4:mplabx}{!h}

\paragraph{Compilador.} El compilador es específico a cada microcontrolador para el cual se desea programar. En este caso corresponde al compilador Microchip XC16 en su versión 1.1, adecuado para la familia de microcontroladores PIC24.

\paragraph{Programador.} El programador utilizado en este caso corresponde al Microchip ICD3, adecuado para ambientes de producción.

\paragraph{Tarjeta de desarrollo}. La tarjeta de desarrollo permite realizar las pruebas sobre el sistema embebido funcionando y es fundamental para el desarrollo de la aplicación del sistema embebido debido a que la aplicación que se desarrolla no se puede ejecutar en el mismo computador, sino que en el sistema objetivo que corresponda. En este caso se utiliza la plataforma de desarrollo que provee el Cubesat Kit de Pumpkins\cite{CUBESAT_DB}. Esta tarjeta de desarrollo permite montar un módulo de procesador con un PIC24F256GA110\cite{PIC24FJ256GA110} y un bus PC104 al cual se conectan todos los componentes del satélite. Cuenta además con un slot de memoria SD, un reloj de tiempo real y un conversor RS232 a USB para fines de \textit{debug} (ver figura \ref{img:ch4:cubesat_db}. La tarjeta de desarrollo es eléctricamente idéntica al la placa madre que se utilizará en el satélite por lo tanto es la herramienta adecuada para realizar todo el trabajo de desarrollo y pruebas del sistema. Se debe hacer hincapié en lo fundamental de esta herramienta en el proceso de desarrollo de un sistema embebido debido a que: la aplicación compilada es específica para el dispositivo objetivo; las herramientas de simulación de microcontroladores no son suficientes para testear las reales condiciones de ejecución de la aplicación; y porque el ciclo de desarrollo se completa con la resolución y ajuste de problemas observados durante la ejecución de la aplicación en su sistema objetivo y de manera dinámica como resultado de respuestas a entradas no deterministas.

\figura{img/cubesat_db.jpg}{scale=0.5}{Tarjeta de desarrollo para Cubesat Kit de Pumpkins}{img:ch4:cubesat_db}{!h}

\section{Organización del proyecto}

\subsection{Directorios}
Con el objetivo de mantener un orden lógico a lo largo del desarrollo del software se debe dar una estructura lógica a los diferentes archivos fuentes que lo componen. Así se organiza un árbol de directorio que permita encontrar de manera sencilla cada archivo fuente según su función en el sistema. La organización de los directorios sigue la arquitectura de capas a nivel global de la aplicación quedando de la siguiente manera
\begin{verbatim}
	  +-main/
	  |
	  +-Drivers/
	  | |
	  | +-include/
	  |
	  +-<RTOS>/
	  |
	  +-Payloads/
	  | |
	  | +-Cmd/
	  | | |
	  | | +-include/
	  | | 
	  | +-Drivers/
	  |   |
	  |   +-include/
	  | 
	  +-<Proyecto>.X/
	  |
	  +-System/
	  | |
	  | +-include/
	  |
	  |_main.c
\end{verbatim}

Los desarrollos deben seguir esta estructura al momento de agregar archivo con código fuente al sistema. En la tabla \ref{ch4:table:directory} se detalla la funcionalidad de cada directorio.

\begin{table}[ht!] \caption{Organización de directorios del proyecto}
\centering
\begin{tabularx}{\textwidth}{lX}\hline
\textbf{Directorio} & \textbf{Descripción}\\\hline
\texttt{main} & Directorio principal, contiene el archivo main.c y archivos de configuración globales\\
\texttt{include} & Dentro de cada directorio de fuentes, se agrega un directorio \textit{include} que contiene las cabeceras de cada archivo fuente en el nivel superior.\\
\texttt{Drivers} & Contiene las fuentes para los drivers del sistema como el computador a bordo, el sistema de comunicaciones y el sistema de energía.\\
\texttt{<RTOS>} & Carpeta con el nombre del sistema operativo. Contiene los archivos fuentes, cabeceras y librerías del sistema operativo según su organización particular.\\
\texttt{Payloads} & Comandos y drivers relacionados con \textit{payloads}. Se encuentra en un directorio aparte pues acá se concentrarán la mayoría del software específico de la misión.\\
\texttt{Payloads/Cmd} & Implementación de comandos del sistema relacionados con \textit{payloads}.\\
\texttt{Payloads/Drivers} & Implementación de drivers relacionados con \textit{payloads}.\\
\texttt{<Proyecto>.X} & Directorio con la configuración del proyecto generado por el IDE MPLABX.\\
\texttt{System} & Archivos con las fuentes del sistema base, incluye implementación de comandos, repositorios y tareas.\\
\hline
\end{tabularx} \label{ch4:table:directory}
\end{table}

\subsection{IDE}
Esta estructura de directorios creada es la base para configurar adecuadamente los archivos con las fuentes del proyecto en el IDE, en este caso MPLAB X. Para la correcta construcción de software en el IDE se deben ajustar las configuraciones del compilador según las indicaciones de la tabla \ref{ch4:table:xc16:configuracion} (parámetros no mencionados mantienen su configuración por defecto):

\begin{table}[ht!] \caption{Configuración del compilador XC16}
\centering
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{3cm} >{\raggedright}p{5cm} X}\hline
\multicolumn{3}{c}{\textbf{XC16}}\\\hline
\multicolumn{3}{c}{\textbf{xc16-gcc}}\\\hline

\multicolumn{3}{c}{\textbf{Categoría: Memory Model}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Code model & Large & El tamaño de la aplicación supera el espacio de memoria cercano.\\
Data model & Large & El tamaño de la aplicación supera el espacio de memoria cercano.\\
Scalar model & Large & El tamaño de la aplicación supera el espacio de memoria cercano.\\
Location of constant model & Code space & \\
\hline

\multicolumn{3}{c}{\textbf{Categoría: Optimizations}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Optimization level & 0 & Las optimizaciones pueden introducir cambios en la forma de ejecución del código, por ejemplo, evitar ciclos \texttt{for} o \textit{while} que realizan \textit{busy waitings}.\\
\hline

\multicolumn{3}{c}{\textbf{Categoria: Preprocessing and messages}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
C include dirs & \texttt{..; ../Drivers/include; ../System/include; ../<RTOS>/<include>; ../Payloads/Cmd/include; ../Payloads/Drivers/include} & Configura los directorios donde el IDE busca las cabeceras para poder incluirlas solo por su nombre y activar el auto completado.\\
Additional warnings & Seleccionada & Permite un nivel mayor de advertencias en tiempo de compilación\\
\hline

\end{tabularx} \label{ch4:table:xc16:configuracion}
\end{table}

Ejemplos del dialogo para configurar las opciones del compilador en MPLAB X se detallan en la figura \ref{ch4:xc16:config}.

%···················· FIGURE ····················
\begin{figure}[ht!] \centering
\subfloat[]{\includegraphics[width=0.48\textwidth]{img/xc16_config_mem.png}}
% \subfloat[]{\includegraphics[width=0.3\textwidth]{img/xc16_config_opt.psng}}
\hspace{0.3cm}
\subfloat[]{\includegraphics[width=0.48\textwidth]{img/xc16_config_prep.png}}
\caption{Diálogo de configuración del compilador XC16 en MPLABX}\label{ch4:xc16:config}
\end{figure}
%················································

\section{Controladores de hardware}
La primera capa de la aplicación corresponde a una serie de módulos que implementan los controladores de hardware. En este caso un módulo significa una librería que consiste en una serie de funciones escritas en lenguaje C las cuales acceden a funcionalidades específica de cierto hardware respetando sus protocolos o API. La librería consta entonces de su correspondiente archivo fuente con extensión \texttt{.c} y un archivo de cabecera con extensión \texttt{.h} que contiene la declaración de las funciones.

La hoja de datos de cada dispositivo de hardware entrega la información necesaria para poder configurarlo y acceder a sus funciones. Se puede requerir de diferentes niveles de abstracción a la hora de implementar el controlador:
\begin{enumerate}
    \item Programar en lenguaje ensamblador (\textit{assembler}). Se maneja directamente el juego de instrucciones del procesador (también conocido como lenguaje máquina) para configurar sus registros, manejar periféricos o ejecutar un programa general. Requiere de un compilador de \textit{assembler} para generar el ejecutable binario.
    \item Utilizar un compilador en C. El compilador provee un nivel mayor de abstracción al permitir programar en un lenguaje de alto nivel y portable como C. Además provee librerías básicas para las funciones específicas de cada dispositivo.
    \item Utilizar una librería externa. Un controlador de hardware puede requerir los servicios de otro controlador para su funcionamiento. Es el caso típico de dispositivos que utilizan algún protocolo de comunicación (RS232, SPI, I2C) y su controlador consiste en implementar una API de llamadas sobre este protocolo.
\end{enumerate}

En este caso se hará un uso extensivo de las librerías escritas en C que provee el compilador XC16 para construir drivers más complejos a través de sus funciones base. Lo principal es implementar los drivers de cada periféricos disponible en el microcontrolador pues serán los recursos que utilizarán los dispositivos externos que completan el sistema del satélite.

\subsection{Microcontrolador}

\subsection{Periféricos}
En la sección \ref{ch2:embedded:perif} se revisaron los periféricos disponibles en el PIC24F256GA110 en la tabla \ref{ch4:table:perif:list} se detalla la lista de drivers a implementar y la arquitectura que se utilizará en cada uno de ellos.

\begin{table}[ht!] \caption{Drivers para periféricos del microcontrolador}
\centering
\begin{tabular}{ll}\hline
\textbf{Periférico} & \textbf{Arquitectura} \\
Timers & \\
PWM & \\
I2C & \\
SPI & \\
UART & \\
Input Capture & \\
RTCC & \\
CRC & \\
Comparadores & \\
ADC & \\
\\hline
\end{tabular} \label{ch4:table:hardware_req}
\end{table}

\subsubsection{Implementación de un controlador síncrono}

\subsubsection{Implementación de un controlador asíncrono}

\section{Sistema operativo}
En la capa de sistema operativo se ha optado por utilizar FreeRTOS. Este sistema operativo está diseñado específicamente para sistema embebidos y provee la capacidad de implementar tareas que son módulos de software que funciona de manera concurrente y puede compartir información a través de diferentes estructuras de sincronización. FreeRTOS soporta una gran variedad de microcontroladores, entre los cuales se encuentra la familia PIC24F, a través de \textit{ports} y aplicaciones demo que se obtienen al descargar el software. FreeRTOS consiste básicamente de 5 archivos fuentes en lenguaje C (sólo tres son necesarios para la utilidad básica), 11 archivos de cabecera y una capa portable dependiente del dispositivo sobre el cual se trabaja. Fuera de los demos y diferentes ports incluidos con la descarga el siguiente árbol de directorio se agrega a la carpeta del proyecto y en la configuración del proyecto en MPLABX:

\begin{verbatim}
FreeRTOS/Source/tasks.c
FreeRTOS/Source/queue.c
FreeRTOS/Source/list.c
FreeRTOS/Source/portable/[compiler]/[architecture]/port.c
FreeRTOS/Source/portable/[compiler]/[architecture]/portasm_[architecture].S
FreeRTOS/Source/portable/MemMang/heap_2.c
FreeRTOS/Source/include
FreeRTOS/Source/portable/[compiler]/[architecture]
\end{verbatim}

Se requieren algunas configuraciones extra en el compilador para el correcto funcionamiento de FreeRTOS, como se detalla en la tabla \ref{ch4:table:xc16:configuracion:freertos}

\begin{table}[ht!] \caption{Configuración del compilador XC16 para FreeRTOS}
\centering
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{3cm} >{\raggedright}p{5cm} X}\hline
\multicolumn{3}{c}{\textbf{XC16}}\\\hline

\multicolumn{3}{c}{\textbf{xc16-gcc}}\\\hline
\multicolumn{3}{c}{\textbf{Categoría: Optimizations}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Omit frame pointer & Seleccionada & Ver documentación de FreeRTOS.\\
\hline
\multicolumn{3}{c}{\textbf{Categoría: Preprocessing and messages}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
Define C macros & \texttt{MPLAB\_PIC24\_PORT} & Ver documentación de FreeRTOS.\\
\hline

\multicolumn{3}{c}{\textbf{xc16-as}}\\\hline
\multicolumn{3}{c}{\textbf{Categoría: General Options}}\\\hline
\textbf{Opción} & \textbf{Valor} & \textbf{Observaciones}\\\hline
ASM include dirs & \texttt{../FreeRTOS/Source/portable/MPLAB/PIC24\_dsPIC/} & Funciones \textit{assembler} específicas de la arquitectura.\\
\hline

\end{tabularx} \label{ch4:table:xc16:configuracion:freertos}
\end{table}

El primer paso para integrar el sistema operativo es crear el archivo de cabecera con su configuración llamado \texttt{FreeRTOSConfig.h}. El archivo se compone de una serie de 	\textit{defines} que cambian el comportamiento del sistema operativo y lo ajustan a las necesidades de la aplicación. Una plantilla con los posibles valores a configurar se encuentra en la página web de FreeRTOS: \url{http://www.freertos.org/a00110.html}. Un ejemplo de este archivo se detalla en el código \ref{ch4:code:FreeRTOSConfig.h}

\begin{lstlisting}[float,label=ch4:code:FreeRTOSConfig,caption=FreeRTOSConfig.h]
#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

#include <xc16.h>

#define configUSE_PREEMPTION			1
#define configUSE_IDLE_HOOK				1
#define configUSE_TICK_HOOK				0
#define configTICK_RATE_HZ				250
#define configCPU_CLOCK_HZ				16000000
#define configMAX_PRIORITIES			4
#define configMINIMAL_STACK_SIZE		115
#define configTOTAL_HEAP_SIZE			5120
#define configMAX_TASK_NAME_LEN			8
#define configUSE_TRACE_FACILITY		0
#define configUSE_16_BIT_TICKS			1
#define configIDLE_SHOULD_YIELD			1

#define INCLUDE_vTaskPrioritySet		1
#define INCLUDE_uxTaskPriorityGet		0
#define INCLUDE_vTaskDelete				0
#define INCLUDE_vTaskSuspend			1
#define INCLUDE_vTaskDelayUntil			1
#define INCLUDE_vTaskDelay				1

#define configKERNEL_INTERRUPT_PRIORITY	0x01

#endif /* FREERTOS_CONFIG_H */
\end{lstlisting}
