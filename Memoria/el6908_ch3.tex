\chapter{Diseño del software}

\section{Resumen}

En este capítulo se describe el proceso de diseño del software de control para el satélite. El proceso de diseño considera en primera instancia los requerimientos operacionales de la misión; requerimientos no operacionales relacionados con la calidad del software; la plataforma de hardware sobre la que se debe diseñar para tener claro las limitaciones y alcances del diseño final. El diseño del la aplicación se detalla en diferentes niveles, incluyendo una visión global sobre los componentes principales de ésta y se centra en específico en el diseño de una arquitectura a nivel de aplicación basada en un patrón de diseño. Finalmente se realiza un análisis del diseño para plantear una arquitectura final que permita implementar todas las funcionalidades detalladas en los requerimientos no operacionales.

\section{Requerimientos}
\subsection{Requerimientos operacionales}
Los requerimientos operacionales se refieren a las funcionalidades que se espera que el computador a bordo del bus SUCHAI deba realizar. Estos requerimientos son los requisitos básicos que el sistema debe cumplir para considerar que se cuenta con un satélite capaz de llevar a cabo la misión del proyecto SUCHAI y son clasificados según el área de la misión que se ve afectada.

La lista de requerimientos proviene de una serie de reuniones sostenidas con los integrantes de los diferentes grupos de trabajo según los lineamientos del jefe de proyecto.

\subsubsection{Área de comunicaciones}
\paragraph{Configuración inicial del \textit{transcevier}.}
El satélite debe ser capaz de fijar las configuraciones iniciales del sistema de comunicaciones como encender el \textit{transcevier}, silenciar las comunicaciones durante determinado tiempo inmediatamente después del lanzamiento, configurar la frecuencia de transmisión a la frecuencia asignada por la IARU y la potencia, configurar y encender beacon, entre otros.

El sistema debe almacenar de manera permanente estas configuraciones iniciales, para reconfigurar el \textit{transcevier} en caso de reinicio o falla así como permitir una reconfiguración de parámetros durante el desarrollo de la misión.

\paragraph{Despliegue de antenas.}
El satélite, luego de transcurrido el tiempo de silencio radial obligatorio, debe desplegar las antenas de comunicaciones con la estación terrena. Esto se realiza mediante la activación de algún sistema eléctrico, que cuenta con cierto sistema de retroalimentación para comprobar que las antenas fueron efectivamente desplegadas. Esta operación puede requerir sucesivos intentos, hasta que las antenas sean desplegadas.

\paragraph{Procesamiento de telecomandos.}
El sistema de comunicaciones debe ser capaz de recibir telecomandos desde la estación terrena y el software de control deberá recogerlos y ejecutar las acciones requeridas. Esto incluye la definición de un formato de telecomandos; la capacidad del sistema de analizar los comandos y sus argumentos dentro de un paquete de comunicaciones; y la posterior ejecución del comando recibido.

\paragraph{Protocolo de enlace.}
El satélite debe ser capaz de recibir y enviar datos a la estación terrena, para esto se requiere en primer lugar, que el satélite se pueda rastrear para lo cual se debe emitir una señal de baliza o \textit{beacon}; segundo, el satélite debe escuchar la estación terrena para determinar si se recibirán ordenes o se descargará información; y tercero, establecer un protocolo de enlace que permita realizar las operaciones de descarga y subida de datos.

\paragraph{Envío de telemetría.}
El satélite recolectará los datos requeridos por la misión, que incluyen información general sobre el estado del vehículo espacial y sus subsistemas así como los datos generados por \textit{payloads} abordo. El envío de telemetría puede ser automático cada vez que el satélite se enlace con la estación terrena o bajo demanda a través de telecomandos que indiquen el tipo de información que es requerida.

\subsubsection{Control central}
\paragraph{Organizar telemetría.}
Durante la misión se generarán datos que provienen de diferentes subsistemas o \textit{payloads}. Se debe contar con un medio de almacenamiento con la capacidad adecuada para mantener estos datos y un sistema de organización de los diferentes datos guardados con el objetivo de ser requeridos de manera selectiva para ser enviados como telemetría a la estación terrena.

\paragraph{Plan de vuelo.}
El satélite debe ser capaz de recibir y ejecutar un plan de vuelo consistente en una serie de acciones a ejecutar en momentos determinados de tiempo. El plan de vuelo puede ser precargado en el satélite antes de ser lanzado así como ser actualizado mediante telecomandos. Esto provee flexibilidad en las tareas que se ejecutarán durante la misión, permitiendo controlar el uso de los diferentes recursos del satélite.

\paragraph{Obtener el estado del sistema.}
De manera autónoma el software de control debe recolectar información básica sobre el estado del sistema en general. Esta información será usada para determinar la salud del sistema y tomar las acciones necesarias en vuelo o bien será descargada como telemetría para ser posteriormente analizada. Ejemplos de variables asociadas al estado del sistema son el nivel de carga de las baterías, la hora del sistema, el estado del sistema de comunicaciones, el estado del sistema de control, entre otras.

\paragraph{Inicialización del sistema.}
El software control debe poseer un algoritmo de inicio del sistema en general, que considera la inicialización del software con los parámetros adecuados a un estado adecuado, la inicialización de otros módulos o subsistemas así como las obligaciones de silencio radial durante el lanzamiento, despliegue de antenas, etc.

El software de control debe tener la capacidad de reiniciarse de manera segura y considerando variables fundamentales del estado anterior al reinicio.

\subsubsection{Área de energía}
\paragraph{Estimación de la carga de la batería.}
El software de control debe considerar un método de estimación de la carga de las baterías del satélite. Esta información debe estar a disposición como una variable del sistema para ser utilizado por el sistema de control de energía utilizada por el satélite.

\paragraph{Presupuesto de energía.}
Se debe considerar la cantidad de energía disponible en el satélite para ejecutar las acciones requeridas. Asimismo se debe tener claro el presupuesto energético de cada acción que se realiza en el satélite. El software de control debe plantear una estrategia para evitar que se ejecuten acciones que estén fuera del presupuesto energético disponible así como una manera de planificar el consumo energético de la misión.

\subsubsection{Órbita}
\paragraph{Actualizar parámetros de órbita.}
Se debe contar con una estrategia de estimación y actualización de los parámetros de órbita del satélite con el objetivo de contar con la información necesaria para la ejecución de acciones dependientes de la posición real de satélite. Ejemplos de este tipo de acciones son la ejecución de un experimento en algún \textit{payload} o en enlace con una estación terrena para descargar datos de telemetría.

\subsubsection{\textit{Payloads}}
\paragraph{Ejecución de comandos de \textit{payloads}}.
El sistema de control debe tener la capacidad de controlar diferentes subsistemas asociados a \textit{payloads} del satélite. Se debe considerar que los \textit{payloads} abordo del satélite pueden variar de misión en misión e incluso pueden ser descartados o agregados en etapas tardías del proyecto. Por eso el sistema de control debe ser flexible en la capacidad de agregar o eliminar módulos que se relacionen con el control de \textit{payloads} sin afectar al resto de los sistemas.

\subsubsection{Tolerancia a fallos}
El sistema debe tener cierto grado de tolerancia a fallos de hardware y software que permitan mantener la misión operativa. Debido las adversas condiciones del medio espacial y la incapacidad de acceder directamente al dispositivo este debe ser capaz de:
\begin{itemize}
	\item Restablecer su funcionamiento normal luego de un reinicio, evitando la pérdida de información
	\item Restablecer el funcionamiento del sistema ante fallas causadas por radiación.
	\item Recuperarse ante fallas de software
	\item Establecer estados de funcionamiento según nivel de fallas.
	\item Detectar y solucionar problemas al desplegar antenas.
	\item Capacidad de \textit{debug} durante el desarrollo y previo lanzamiento
\end{itemize}

\subsection{Requerimientos no funcionales}
Por requerimientos no funcionales se entienden aquellos atributos asociados a la calidad del software o criterios que permiten determinar cómo debería ser el software que se está diseñando. A diferencia del los requerimientos funcionales que explican lo que el software debería hacer, los requerimientos no funcionales explican las cualidades y restricciones que guiarán el proceso de diseño.

El eje principal para el diseño del software de control del satélite responde a contar con un software que sea altamente mantenible debido a dos factores básicos: primero, el desarrollo del software será incremental, estará a cargo de más de una persona, por lo tanto debe ser flexible en la adición de funcionalidades desacoplando módulos para que las intervenciones en el código sean lo más acotadas posible; segundo, el sistema debe ser la base para futuras misiones aeroespaciales, por lo tanto debe ser fácilmente adaptable a nuevos requerimientos funcionales que incluyen la adición de nuevos \textit{payloads} y sus módulos de control. En el futuro la arquitectura del sistema debe proveer la capacidad de análisis del sistema a los nuevos desarrolladores con el objetivo de determinar claramente qué módulos se deben intervenir para agregar nuevas funcionalidades o corregir posibles errores. Especial mención requiere la necesidad de expandir el sistema, pues se considera como filosofía de trabajo en el proyecto 
SUCHAI el contar siempre con un sistema funcional ante la eventual posibilidad de lanzar el satélite. Así, se partirá implementado un sistema que realice las operaciones básicas o requerimientos mínimos para así agregar complejidad y funciones al software de manera incremental. Lo anterior conduce a poner especial énfasis en el diseño de una arquitectura que genere un software modular, reusable, analizable y modificable, elementos agrupados en la característica 'mantenible' de la norma ISO/IEC 25010\cite{ISO25010}.

La fiabilidad del sistema es un elemento importante en cualquier misión espacial debido al ambiente extremo en el cual se desarrolla la misión, lo que incluye grandes cambios de temperatura y los efectos de la radiación solar sobre los componentes electrónicos\cite{REQUERIDA}. Esto significa que el sistema debe tener una nivel de tolerancia a fallas y ser capaz de recuperarse ante una interrupción o fallo. En lo que a software respecta, la característica de tolerancia a fallos será considera en su nivel básico, debido a que por lo general esto significa diseñar sistemas altamente redundantes con una serie de estados de funcionamiento que elevan la complejidad del diseño siguiendo una línea contraria a otros requerimientos no operacionales.

%CITAR MEMORIAS QUE HABLEN DE TOLERANCIA A FALLAS

La idoneidad funcional es un requisito importante, desde el siguiente punto de vista: si bien en la etapa de diseño no se busca obtener una solución detallada de la implementación de cada uno de los requerimientos operacionales, la arquitectura seleccionada de tener una respuesta a cada función necesaria de implementar para ser considerada como válida. Posiblemente en las primeras iteraciones se busque cumplir con los requisitos mínimos de la misión, pero la arquitectura debe ser la idónea para delinear claramente la forma de agregar todas las funcionalidades requeridas y que las tareas requeridas sean llevadas a cabo de manera correcta.

Existen algunos características de calidad que no serán relevantes en este diseño ya que al ser la primera aproximación en la materia para el equipo se requiere mantener cierto nivel de simplicidad en la solución, luego probarla y así ganar la experiencia necesaria en el desarrollo de tecnología aeroespacial. Por ejemplo el desempeño, referido a términos computacionales, no es una restricción importante por la siguientes razones: se cuenta con una plataforma de baja capacidad de cómputo y limitados recursos energéticos; el sistema requiere realizar una cantidad limitada de tareas; tareas de alta demanda computacional pueden ser realizadas en tierra; y no se consideran tareas que requieran una gran precisión de tiempo. La seguridad tampoco es una componente fundamental, si bien, se podría requerir evitar un uso mal intencionado de la plataforma por parte de otros operadores satelitales -salvo por errores- esto es poco probable; por el contrario se busca obtener la mayor cooperación posible de otros operadores 
como por ejemplo la comunidad de radioaficionados. Por último en el caso de la portabilidad, lo único importante es determinar claramente los diferentes niveles de abstracción de la arquitectura y su intercomunicación, debido a que por la naturaleza de las plataformas a que se apunta se cuenta con muy bajo nivel de estandarización en los niveles más cercanos al hardware.

Por último la tabla \ref{tbl:ch2:req_no_func} resume los requerimientos no funcionales del proyecto asignándole cierta prioridad o importancia a considerar en el diseño.

\tabla{tablas/req_no_operacionales.pdf}{width=\textwidth}{Requerimientos no funcionales}{tbl:ch2:req_no_func}{!h}

\subsection{Requerimientos mínimos}
Para que el sistema desarrollado en el proyecto SUCHAI pueda considerarse como un satélite, el vehículo debe satisfacer al menos los requerimientos mínimos dispuestos en la tabla \ref{tbl:ch2:req_min}.

\tabla{tablas/req_minimos.pdf}{scale=1.0}{Requerimientos no mínimos}{tbl:ch2:req_min}{!h}

Dada la naturaleza iterativa de la metodología de trabajo, es importante considerar los requerimientos mínimos a la hora de la implementación de la arquitectura pues dará al sistema la simplicidad necesaria asegurando funcionalidad. La completitud de los requerimientos operacionales se obtendrán como mejoras incrementales sobre los requerimientos mínimos ya mencionados.

\section{Plataforma}
La plataforma para la cual se diseña el software corresponde a un kit Cubesat de una unidad adquirido a la compañía Pumpkins Inc. El kit está compuesto por una chasis de 1U con caras perforadas, un computador abordo con placa madre tipo 
%TODO COMPLETAR

%Figura - CubesatKit 1U
\figura{img/cubesatkit_1u.jpg}{scale=1}{Chasis Pumpkins para Cubesat de 1U}{img:ch3:cubesatkit_1u}{!h}

\subsection{Computador a bordo}

%Figura - On board computer
\begin{figure}[ht!] \centering
	\subfloat[Placa madre]{\includegraphics[scale=0.4]{img/mb.jpg}}
	\hspace{1cm} %Espacio horizontal
	\subfloat[Módulo del procesador]{\includegraphics[scale=0.4]{img/ppm.jpg}}
	\caption{Dos módulos que componen el computador a bordo del satélite}\label{img:ch3:obc}
\end{figure}

El computador a bordo del satélite está compuesto por una placa madre que contiene un conector PC104 a través del cual se conectan el resto de los subsistemas y por el módulo para el procesador que se conecta directamente a la placa madre.

La placa cuenta además con un reloj de tiempo real que se comunica por I2C el cual puede ser usado como reloj, alarma y/o \textit{watchdog} externo; cuenta con una interfaz de memoria SD para contar con un medio de almacenamiento masivo de hasta 2GB; una interfaz USB 2.0 para comunicaciones previas al lanzamiento; así como la electrónica para proveer alimentación al bus PC104 y al módulo del procesador\cite{CUBESAT_MB}.

El módulo del procesador cuenta con un microcontrolador PIC24FJ256GA110; una memoria flash de 64Mbit con interfaz SPI; osciladores; circuitos de alimentación, protección de sobre corriente y reset. El microcontrolador posee la siguientes características\cite{CUBESAT_PPM}:

\begin{itemize}
	\item Arquitectura de 16 bit.
	\item Memoria de programa flash de 256KB.
	\item 16KB de memoria SRAM.
	\item Hasta 16MIPS @ 32MHz.
	\item 4 UARTs, 3 SPIs, 3 I2Cs.
	\item ADC de 10bit, 16 canales, 500ksps.
	\item 5 timers de 16bit.
	\item RTCC, WDT
\end{itemize}

Como se observa las capacidades de cómputo de las plataformas son muy limitadas, así como la cantidad de memoria de programa y de datos disponible. Esto supone fuertes restricciones tanto en el diseño e implementación del software en tanto no se puede recurrir a alternativas como un sistema operativo Linux o utilizar lenguajes de programación interpretado tipo Java o Python. Las implicancias de las restricciones impuestas por la plataforma de hardware derivan en los siguientes puntos:

\begin{itemize}
	\item Se deberá utilizar las herramientas de desarrollo que provee el fabricante del microcontrolador, es decir, lenguaje C para el compilador XC16 de Microchip.
	\item Se debe efectuar un trabajo de bajo nivel implementado drivers para los periféricos del microcontrolador y para cada dispositivo que se agrega al sistema.
	\item Sólo existen algunos sistemas operativos básicos para este tipo de dispositivos, y en general permiten organizar el software en módulos, procesos o tareas que se ejecuten de manera concurrente.
	\item Existe una cantidad muy limitada de código previo, reutilizable, para implementar el diseño de la aplicación, descartando de plano la posibilidad de utilizar bases de datos tipo SQL, protocolos TCP, UDP o librerías POSIX.
\end{itemize}

Con todo el diseño de la aplicación final será a medida y no deriva de un trabajo previo, con el objetivo de ajustarse a los requerimientos y restricciones de la mejor manera posible.




\section{Arquitectura de software}
\subsection{Arquitectura Global}
En este nivel se propone una arquitectura de capas. Las diferentes capas agrupan funcionalidades similares y cada una interactúa sólo con la directamente superior e inferior, en una dinámica donde la capa inferior es una prestadora de servicios para la capa superior\cite{SOFTWARE_ING}. Esta arquitectura es una buena forma de proveer sistemas portables entre diferentes plataformas de hardware porque en cuanto se mantengan las interfaces entre capas, cualquiera de ellas puede ser reemplazada por una implementación diferente. La figura \ref{img:ch3:arch_global} detalla una arquitectura de tres capas apropiada en general para el diseño de software en sistemas embebidos donde se pueden distinguir al menos tres niveles: capa de bajo nivel relacionada con los controladores de hardware, también llamada a menudo como capa de abstracción de hardware o HAL por sus siglas en inglés; la cada intermedia que corresponden al nivel del sistema operativo o gestor de tareas del sistema; y una capa superior que corresponde a la 
aplicación final del sistema.

\figura{img/arch_global.pdf}{scale=0.9}{Arquitectura de tres capas para un sistema embebido.}{img:ch3:arch_global}{!h}

La capa de más bajo nivel corresponde a los controladores de hardware, que pueden ser varios módulos específicos a cada pieza de hardware o subsistema presente y permite a las capas superior acceder al hardware sin conocer en detalle sus particularidades. Por ejemplo esta capa presta los servicios de acceder a periféricos de comunicaciones o subsistemas de hardware externo como puden ser los diferentes \textit{payloads}. Por lo general existen varias alternativas de hardware disponibles para un mismo objetivo o bien se requiere que el sistema se adapte a la presencia de diferentes \textit{payloads}, la integración de variado hardware en este nivel permite mantener el resto del sistema intacto siempre y cuando se respeten las interfaces entre capas.

La capa intermedia corresponde al sistema operativo, que provee soporte para la gestión de tareas en el sistema embebido permitiendo la ejecución concurrente de procesos. A este nivel de diseño la decisión de qué sistema operativo utilizar no es relevante, pues toda la lógica de gestión de tareas está concentrada en esta capa que utilizará las funcionalidades dadas por la capa de más bajo nivel y provee sus funcionalidades a la capa superior o de aplicación.

La capa superior es específica a la aplicación e implementa la funcionalidad final del sistema embebido que se diseña. Nuevamente se observa la ventaja de utilizar un diseño de capas en la arquitectura global, en cuanto la capa inferior e intermedia será común en cualquier sistema embebido y el diseño de la aplicación final puede contar con estos servicios. Esto significa que al implementar ambos niveles se tiene un porcentaje considerable de un nuevo desarrollo listo.

Una de las principales desventajas de esta arquitectura, sobre todo en sistema embebidos, es puede existir la necesidad de una comunicación entre capas no adyacentes\cite{SOFTWARE_ING} rompiendo la arquitectura. Esto se debe tratar de evitar, o al menos realizarlo de manera controlada.

\subsection{Controladores de hardware}
En todo sistema computacional se requiere de una capa de bajo nivel que realice la interfaz entre el hardware y el software, para entregar las funcionalidades de configurar, controlar y deshabilitar adecuadamente las diferentes piezas de hardware. Se llaman controladores de hardware o \textit{drivers} a aquellas librerías de software que permiten inicializar y manejar el acceso a este hardware por parte de las capas superiores de sistema operativo y aplicación\cite{EMBEDDED_ARCHITECTURE}.

Se requiere al menos un controlador para cada hardware existente en el sistema embebido, y se diseñan bajo la idea de agrupar hardware de similares características o funcionalidades bajo una interfaz común que permita abstraer las particularidades de la implementación en cada pieza de hardware. Hacia las capas superiores se maneja el ``que hace'' el dispositivo entregando por lo general funciones básicas que persisten entre diferentes arquitecturas de hardware como: la inicialización, encendido o habilitación del dispositivo; su configuración; la lectura de datos desde el dispositivo; la escritura de datos hacia el dispositivo; y finalmente deshabilitar o apagar este dispositivo. Además cada hardware puede poseer funcionalidades específicas que también deben ser accesibles a través del driver.

Hacia la capa de hardware el controlador maneja el ``como'', lo que incluye por lo general el manejo de las interfaces de entrada y salida de datos; manejo de las interrupciones; o manejo de la memoria del dispositivo. Si bien la implementación de cada controlador es específica al dispositivo, se pueden diferenciar al menos tres tipos de arquitecturas comunes en la implementación de estas piezas de software: controladores de entrada y salida síncronos; controladores de entrada y salida asíncronos; y colas de entrada de datos seriales.

\subsubsection{Controladores de entrada y salida síncronos}
Se considera el uso de una arquitectura de controladores síncronos cuando las tareas que lo invocan necesariamente deben esperar la respuesta del controlador. Si se provee la adecuada sincronización, entonces el resto del sistema puede seguir funcionando mientras la tarea en cuestión se encuentra esperando. Cuando el controlador termina el proceso de entrada o salida de datos, la tarea retoma su funcionamiento.

La arquitectura correspondiente se detalla en la figura \ref{img:ch3:driver:sincrono} donde se observa que el driver se provee como un módulo, o función, que es llamado por alguna capa superior en la arquitectura. Una vez que el controlador tiene acceso al dispositivo a través de alguna estructura de sincronización realiza las operaciones de entrada y salida. Estas operaciones se pueden o no realizar a través de rutinas de atención de interrupciones o bien mediante un \textit{polling} al estado del dispositivo. Si se usa la rutina de atención de interrupciones, esta pieza de software también se considera parte del controlador.

\figura{img/driver_sincrono.pdf}{scale=1.3}{Arquitectura para controladores síncronos}{img:ch3:driver:sincrono}{!h}

El módulo del controlador realiza las siguientes acciones:
\begin{itemize}
	\item Iniciar las operaciones de entrada y salida.
	\item Esperar por una estructura de sincronización.
	\item Obtener el estado o la información desde el dispositivo.
	\item Retornar la información requerida.
\end{itemize}

Cuando se utiliza una rutina de atención de interrupciones, esta se encarga de las siguientes operaciones:
\begin{itemize}
	\item Atender la interrupción y restablecer el estado del dispositivo.
	\item Obtener datos desde, o agregar datos en el dispositivo
	\item Liberar la estructura de sincronización cuando se terminen las operaciones.
\end{itemize}

\subsubsection{Controladores de entrada y salida asíncronos}
En ocasiones la tarea que solicita a acciones al controlador puede continuar su ejecución sin esperar el resultado. En esta caso se habla de un controlador asíncrono. Este tipo de driver no es común de encontrar y por lo general se puede evitar cuando, para la tarea que llama al driver, no tiene mucho sentido avanzar en su ejecución antes de que se terminen las operaciones de entrada y salida. Un caso especial corresponde a la ejecución en diferentes etapas de la operaciones del driver, en donde la tarea mandante puede procesar los datos de una etapa mientras el proceso de entrada o salida continua su ejecución.

La arquitectura para este tipo de drivers se detalla en la figura \ref{img:ch3:driver:asincrono}. Se observa que el driver lo componen el módulo o función que ejecuta la operaciones, la rutina de atención de interrupciones así como una cola de mensajes que almacena los resultados parciales de la operación de entrada o salida. Acá el driver se sincroniza con la tarea a través de una cola de mensajes, donde se almacenan los resultados parciales o de cada etapa del proceso completo para que la tarea pueda procesar en paralelo esta información.

\figura{img/driver_asincrono.pdf}{scale=1.3}{Arquitectura para controladores asíncronos}{img:ch3:driver:asincrono}{!h}

Las operaciones que realiza el controlador son las siguientes:
\begin{itemize}
	\item Esperar a que lleguen mensajes a la cola.
	\item Obtener el mensaje y entregar la información a la tarea.
	\item Continuar con nuevas operaciones de entrada o salida.
\end{itemize}

Mientras que en la rutina de atención de interrupciones se realiza lo siguiente:
\begin{itemize}
	\item Atender la interrupción y restablecer el estado del dispositivo.
	\item Obtener la información desde (o enviar hacia) el dispositivo de hardware.
	\item Empaquetar la información en un mensaje.
	\item Agregar el mensaje a la cola.
\end{itemize}

\subsubsection{Cola de entrada de datos seriales}
Un caso particular de driver asíncrono se observa de manera común en sistema embebidos y corresponde a la entrada de datos seriales asíncronos. En este tipo de controladores se cuenta con la llegada de una gran cantidad de datos y donde el término de la operación está determinada por la cantidad máxima de datos recibido o por algún dato indicador del término de la operación.

La arquitectura que responde a esta situación se detalla en la figura \ref{img:ch3:driver:serial}. En este caso además del módulo o función del controlador, la rutina de atención de interrupciones y una cola de mensajes (opcional) se agrega un \textit{buffer} de memoria que es creado previo inicio de las operaciones de entrada de datos y que es accedido por referencia para evitar el uso adicional de memoria y copia de datos entre llamadas.

\figura{img/driver_serial.pdf}{scale=1.3}{Arquitectura de un controlador de entrada serial}{img:ch3:driver:serial}{!h}

Las operaciones que corresponden al módulo del controlador son:
\begin{itemize}
	\item Inicializar un \textit{buffer} de datos.
	\item Si se implementa como driver asíncrono, entonces se espera por la llega de un nuevo mensaje.
	\item Extraer los datos desde el \textit{buffer}
	\item Retornar los datos hacia la tarea
\end{itemize}

Corresponde a la rutina de atención de interrupciones las siguientes operaciones:
\begin{itemize}
	\item Atender la interrupción y restablecer el estado del dispositivo.
	\item Obtener el nuevo dato desde el dispositivo.
	\item Agregar nuevo datos al \textit{buffer} (por referencias).
	\item Si se detectar e final de la operación, señalizar o agregar un mensaje a la cola.
\end{itemize}

\subsection{Sistema operativo}
El sistema operativo es la capa de abstracción entre la capa de aplicación y el hardware en la arquitectura de capas de un sistema embebido. Permite diseñar la aplicación sin considerar las particularidades de la plataforma en que se ejecuta así como estructurar la aplicación en una serie de procesos o tareas cuya gestión la proveen los servicios del sistema operativo.\cite{EMBEDDED_ARCHITECTURE}

Los servicios básicos que provee el sistema operativo a través de su kernel son:
\begin{itemize}
	\item \textbf{Gestión de tareas:} También denominada gestión de procesos. El sistema operativo ve a la aplicación como una serie de tareas o procesos, a las cuales se debe entregar los servicios de creación, ejecución y asignación de prioridades. Cada tarea cumple objetivos específicos en la aplicación y posee sus propios recursos y limitaciones de tiempo. Varias tareas pueden existir a la vez en el sistema y el sistema operativo se encarga de proveer de tiempo de procesamiento a cada una de las tareas disponibles. Existen diferentes alternativas apara gestionar la ejecución de las tareas en el sistema, de las cuales sobresalen dos \textit{preemptive} y cooperativo. La implementación de la aplicación y las tareas dependen mucho del modo de gestión de tareas que utiliza el sistema operativo por lo cual se describe cada modo a continuación:
	\begin{itemize}
		\item \textbf{Modo \textit{preemptive}:} El gestor de tareas puede interrumpir la tarea en cualquier momento de su ejecución para realizar el cambio de contexto y ceder el procesador a una tarea diferente. Por lo generar se realiza a intervalos fijos, denominados \textit{ticks}. Esto puede ir acompañado de un sistema de prioridades, entonces el sistema de gestión de tareas se asegura de que siempre se esté ejecutando la tarea de mayor prioridad disponible.
		
		\item \textbf{Modo cooperativo:} En el modo cooperativo el sistema operativo nunca inicia un cambio de contexto sino que cada tarea en ejecución cede voluntariamente el procesador a una nueva tarea. El sistema operativo es quien decide la siguiente tarea a ejecutar ya sea por el algoritmo de \textit{round robin}, un sistema de prioridades o ambos. Se denomina cooperativo porque todas las tareas deben estar correctamente programadas y cooperar con la ejecución del resto de las tareas iniciado el proceso de cambio de contexto.
	\end{itemize}
	
	\item \textbf{Comunicación y sincronización entre tareas:} Si bien cada tarea posee su propio contexto de ejecución y pueden existir varias tareas funcionando de manera concurrente, la verdadera utilidad nace de la posibilidad de comunicación entre tareas para compartir estados y mensajes que permitan cambiar el flujo de ejecución de las operaciones en el sistema embebido. Así, las tareas compartirán los mismos recursos de hardware o requerirán de memoria compartida en esquemas tipo productor-consumidor donde el sistema operativo es quien provee las estructuras de sincronización adecuadas. El sistema operativo de encarga de proveer los mecanismos de comunicación y sincronización para asegurar que la información compartida no se corrompa y no existan interferencias entre tareas al acceder a recursos compartidos.
	
	\item \textbf{Temporización:} Dado los requerimientos estrictos de tiempo propios de un sistema de tiempo real, el sistema operativo debe proveer servicios de tiempo como \textit{delays} y \textit{time-outs} para controlar la periodicidad o límites de tiempo de ejecución de cada tarea.
	
	\item \textit{Gestión de memoria:}
	
	%TODO AGREGAR IMAGEN CON ARUITECTURA GLOBAL DEL SISTEMA OPERATIVO
	
\end{itemize}



\subsection{Aplicación}

Para el diseño de la aplicación se estudió la adaptación de un patrón de diseño utilizado en la programación orientada a objetos, llamado \textit{command pattern}. Este patrón de diseño soluciona la necesidad de realizar peticiones a diferentes objetos sin necesidad de saber cómo se ejecutaran estas acciones, de este modo la petición es encapsulada en como un comando que entrega al objeto adecuado para ser ejecutado. Este patrón entrega algunas ventajas como: separar los módulos que generan los comandos de aquellos que los ejecutan; la posibilidad de gestionar colas de comandos, registros u deshacer acciones; y ofrecer un flujo uniforme para ejecutar las acciones permitiendo extender el software al agregar comandos nuevos.

%TODO: MAS DETALLES DEL PATRON ESTUDIADO

%TODO: *Solo se justifica tener tareas cuando son activas, no cuando se mantienen dormidas todo el tiempo y se deben sincronizar.

Como las restricciones que se han impuesto al diseño de la aplicación indican que no se utilizará un lenguaje de programación orientado a objetos, se realizará una adaptación de la idea de este patrón de diseño, donde los objetos serán representados como módulos estáticos, con posibilidad de generar comunicación y sincronización entre estos módulos.

%TODO: MAS DETALLES DE LA ADAPTACION

Los módulos fundamentales de la arquitectura son lo siguientes:

\paragraph{Listeners.} Los \textit{listeners} o escuchadores son los módulos en la capa superior de la arquitectura y emulan lo que serían los clientes dentro de \textit{command pattern}. Estos módulos son los únicos encargados de generar los comandos en el sistema. Pueden existir varios \textit{listeners} dado que implementan la inteligencia del sistema para generar la acciones deseadas ante diferentes circunstancias. Su denominación proviene del hecho de que la justificación para que un \textit{listener} exista, es que se mantiene 'escuchando' alguna variable del sistema o el estado de un subsistema para tomar decisiones sobre los comandos que se deben ejecutar en cada momento. Los \textit{listeners} se pueden ver como las 'aplicaciones' o 'procesos' de otras arquitecturas de software para pequeños satélites\cite{ION_TESIS}\cite{POLYSAT_TESIS} en cuanto acá se realizan procesos de manera periódica y se mantienen activos durante todo el funcionamiento del sistema. Estos módulos permiten extender las 
funcionalidades del satélite en cuanto se requiera un aplicación que dado ciertos parámetros, tome decisiones en tiempo real y ejecute las acciones necesarias, por ejemplo, conceptualmente se puede considerar como un \textit{listener} los siguientes procesos:

\begin{itemize}
	\item Dado un temporizador, realizar de manera periódica una revisión del estado del sistema.
	\item Dada la posición actual en la órbita, ejecutar un plan de vuelo.
	\item Dado que llegan telecomandos desde la estación terrena, procesarlos y ejecutar las solicitudes.
	\item Dado que se reciben datos por el puerto serial, procesar y ejecutar las acciones solicitadas.
\end{itemize}

Se hace hincapié en que la existencia de cada \textit{listener} requiere de una subsistema o variable al cual prestar atención, ya sea un temporizador, la posición actual o el arribo de un telecomando por mencionar algunos ejemplos. Una vez definido esto, el programador debe determinar bajo qué condiciones se toma la decisión de generar un determinado comando que realice las acciones requeridas.

Los \textit{listeners} no realizan acciones que involucren directamente el acceso a otros subsistemas, evitando así el uso simultaneo de recursos de hardware -como módulos de comunicaciones- que puedan causar un estado de \textit{data race}. Por lo tanto sólo se permite el acceso al repositorio de estados, repositorio de datos y repositorio de comandos. Tampoco en este nivel se ejecutan directamente los comandos, sino que son generados y encolados para su posterior funcionamiento. Esto plantea la limitante de que quien envía el comando no puede saber si fue ejecutado o cuál fue el resultado de su ejecución. No obstante se puede lograr la retroalimentación necesaria a través de la lectura por parte del \textit{listener} del repositorio de estados y de la modificación de un estado en este repositorio por parte del comando generado.

\paragraph{Dispatcher.} El siguiente nivel en la arquitectura es el módulo \textit{Dispatcher}. Dentro del patrón de diseño original tiene su símil con el objeto denominado \textit{Invoker} en cuanto es el encargado de pedir la ejecución de un comando generado por un \textit{listener}. Todos los comandos que son generados por los múltiples \textit{listeners} llegan a al módulo \textit{dispatcher} y son encolados, en este nivel se realiza un control sobre los comandos que llegan y se pueden establecer políticas de rechazo a la ejecución de comandos. Si el comando es aceptado el \textit{dispatcher} encargará su ejecución al siguiente nivel de la arquitectura. Entre las responsabilidades que pueden ser asignadas se encuentran:

\begin{itemize}
	\item Recibir todos los comandos generados y decidir si serán enviados para su ejecución.
	\item Ordenar la ejecución de comandos según prioridades.
	\item Filtrar comandos según el estado de salud del sistema. Por ejemplo, evitar ejecutar comandos que usan mucha energía cuando
	el nivel de carga de las baterías sea crítico.
	\item Filtrar los comandos provenientes o hacia un determinado subsistema que pueda estar causando fallas.
	\item Llevar un registro de los comandos que se han generado
	\item Llevar un registro del resultado de la ejecución de comandos.
\end{itemize}

Sólo una instancia de este módulo existe en el sistema permitiendo centrar en este apartado las estrategias de control de las operaciones que realizan en el sistema sin afectar el funcionamiento de otras áreas. La información que dispone el \textit{dispatcher} para establecer el control son dos: el estado del sistema obtenido desde el repositorio correspondiente y la meta información disponible en los comandos que son encolados.

\paragraph{Executer.} Corresponde al módulo final en el flujo de comandos del sistema, donde estos son ejecutados. Corresponde al objeto \textit{reciver} dentro del patrón de diseño original en cuanto este módulo es quien finalmente realiza las acciones solicitadas. El \textit{Executer} recibe un comando desde el \textit{Dispatcher} y obtiene la función que se debe ejecutar desde el repositorio de comandos. Se ejecuta la función que realiza todas las acciones que implementa dicho comando como: leer datos, acceder a dispositivos, cálculos y guardar resultados, se espera su término y su código de retorno es notificado finalmente al \textit{dispatcher}.

La funciones del \textit{executer} incluyen recibir el comando, identificar y obtener la función a ejecutar, sus parámetros realizar el llamado a la función, recibir el código de retorno y notificar a al \textit{dispatcher} el resultado del comando. En cuánto a la cantidad de \textit{executers} que pueden existir en el sistema se pueden tomar dos aproximaciones:

\begin{itemize}
	\item \textbf{Executer único:} Tener un sólo \textit{executer} que se ejecuta con máxima prioridad frente a los otros módulos permite brindar acceso exclusivo del sistema al comando en ejecución. Se ahorra de esta manera todos los problemas que surgen de sincronizar el uso compartido de recursos o subsistemas. Sin embargo se debe cuidar que el comando en ejecución no cause una falla que deje al sistema congelado.
	
	\item \textbf{Múltiples executers:} Se puede implementar una patrón \textit{Thread Pool}\cite{REQUERIDA} para permitir la ejecución de varios comandos de manera concurrente. Esto implica tener varios \textit{executers} esperando a recibir comandos desde una cola. Cuando un \textit{executer} esté disponible toma un comando y lo ejecuta, encolando también su resultado. Se puede obtener un sistema que funcione de manera más fluida cuando se cuenta con una alta demanda de comandos, sin embargo se requiere una cuidada sincronización de los recursos compartidos que utilice cada comando para evitar situaciones de \textit{data race}.
\end{itemize}

\paragraph{Repositorios.}

Los módulos en ejecución requieren del acceso a los datos básicos del sistema, que indican el estado de funcionamiento y permiten tomar decisiones según determinadas variables de control; del mismo modo los comandos ejecutados requieren informar de cambios en el estado de funcionamiento, reconfiguración de parámetros y el almacenamiento de datos provenientes de experimentos. Ambas necesidades de acceder a la información disponible en el sistema se abstrae en el concepto de repositorios de datos que son módulos encargados de organizar toda la memoria disponible en el sistema y proveer métodos de acceso que transparenten la lectura y escritura de datos. Los repositorios de datos por lo general no son módulos activos en su ejecución, es decir, se tratan como librerías que proveen funciones para manejar el acceso a los datos, organizar el lugar físico en que se conservará la información y supervisar la integridad de estos sobre todo ante casos de falla o reinicio del sistema.



La arquitectura de software de la aplicación para la operación del satélite queda descrita por el diagrama de la figura \ref{img:ch3:arch} que describe el flujo de información entre los diferentes módulos que componen el software, así como sus dependencias, principales operaciones y su correspondencia con el patrón de diseño que inspira la arquitectura propuesta.

\figura{img/arch_general.pdf}{width=\textwidth}{Arquitectura de software para el control del satélite}{img:ch3:arch}{!h}

%TODO: Flujo de ejecución de la aplicación.

\section{Diseño}

Dado los requerimientos operacionales y no operacionales, así como la arquitectura de software en todos sus niveles, se pasa validar el diseño propuesto para poder asegurar que el software requerido y sus funcionalidades son posibles de implementar con esta solución. Para esto se vuelve a revisar los requerimientos operacionales y se propone una solución conceptual a través de la arquitectura de software propuesta. Los resultados de este proceso para cada área se detallan en las tablas \ref{tab:chp3:analisis:comunicaciones}, \ref{tab:chp3:analisis:controlcentral}, \ref{tab:chp3:analisis:energia} y \ref{tab:chp3:analisis:toleranciafallos}.

%·········· TABLA ··············
\begin{table}[ht!] \caption{Análisis de la arquitectura, según requerimientos operacionales, para él área de comunicaciones}
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{2.5cm} >{\raggedright}p{2.5cm} X}\hline
\multicolumn{3}{c}{\textbf{Área de  comunicaciones}}\\\hline
\textbf{Función} & \textbf{Módulo} & \textbf{Implementación} \\\hline
Configuración inicial del transceiver & Listener (Deployment) & Al inicio del sistema se ejecutan comandos que configuran los parámetros adecuados. El sistema se duerme en su totalidad para respetar el tiempo de silencio radial.\\

Procesamiento de telecomandos & Listener (Communications) & Se consulta periódicamente el estado del transceiver y cuando llega un telecomando se decodifica para generar los comados del sistema correspondientes\\

Protocolo de enlace & Listener (Communications) & Cuando se recibe un telecomando que inicia la sesión de comunicaciones con tierra se generan comandos que responden según el protocolo y cambian el estado del sistema para establecer comunicación.\\

Envío de telemetría & NA & Se reciben telecomandos para envío de telemetría bajo demanda. Se genera el comando adecuado que lee el repositorio de datos y envía la información al subsistema de comunicaciones.\\

Despliegue de antenas & Sistema de inicio & Durante el inicio se activa el sistema de despligue. Se revisa el estado del sensor externo (switch) y se reintenta hasta conseguir el despliegue.\\\hline
\end{tabularx}\label{tab:chp3:analisis:comunicaciones}
\end{table}
%······················

\begin{table}[ht!] \caption{Análisis de la arquitectura, según requerimientos operacionales, para él área de control central}
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{2.5cm} >{\raggedright}p{2.5cm} X}\hline
\multicolumn{3}{c}{\textbf{Área de  control central}}\\\hline
\textbf{Función} & \textbf{Módulo} & \textbf{Implementación} \\\hline

Organizar Telemetría & Repositorio de datos & Se cuenta con un repositorio de datos que brinda acceso de forma ordenada a los diferentes tipos de datos. Existen comandos específicos que recogen la información y usan el repositorio de datos para guardarla.\\

Plan de vuelo & Listener (FlightPlan) & El plan de vuelo consta de un itinerario con los comandos a ejecutar según la ubicación del satélite. Se puede configurar a través de comandos que modifiquen entradas específicas del itinerario.\\

Recoger información del estado del sistema & Listener (HouseKeeping) & De forma periódica se ejecutan comandos que revisan parámetros del sistema y actualizan variables en el repositorio de estados\\

Tolerancia a fallos de software & Dispatcher & Se lleva un registro de los comandos ejecutados y sus códigos de retorno. Se puede evitar le ejecución de comandos (o grupos de comandos) que están generando problemas en el sistema. (Lista negra). Se puede filtrar comandos desde ciertos listeners.\\

Capacidad de debug & Listener (DebugConsole) & Se cuenta con una consola serial capaz de interpretar órdenes como comandos internos del sistema. Comandos se pueden ejecutar en modo debug para tener una salida con información relevante sobre la ejecución.\\

Inicialización del sistema & Listener (Deployment) & Inicialmente sólo existe un listener, que genera los comandos para toda la secuencia de inicio, que implica configurar parámetros, repositorios, subsistemas, silencio radial, despligue de antenas y la activación del resto de los listeners.\\\hline
\end{tabularx}\label{tab:chp3:analisis:controlcentral}
\end{table}
%·····················

\begin{table}[ht!] \caption{Análisis de la arquitectura, según requerimientos operacionales, para él área de energía órbita y payloads}
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{2.5cm} >{\raggedright}p{2.5cm} X}\hline
\multicolumn{3}{c}{\textbf{Área de energía, órbita y payloads}}\\\hline
\textbf{Función} & \textbf{Módulo} & \textbf{Implementación} \\\hline

Estimación de la carga de la batería & Listener (HouseKeeping) & De forma periódica se ejecuta comando que lee datos desde EPS y actualiza variables en el repositorio de estado del sistema.\\

PowerBudget & Dispatcher & Antes de ejecutar un comando se chequea el estado de energía del sistema. Los comandos tienen niveles de energía aceptables y sólo se ejecuta si su nivel requerido es menor o igual al estado de carga actual.\\

Actualizar parámetros de orbita & NA & (1) La orbita se calcula en tierra y se actualiza el itinerario según las predicciones de órbita. (2) Se cuenta con un sibsistema GPS. Se ejecutan el itinerario según coordenadas espaciales.\\

Ejecución de comandos de Payloads & Listener (FlightPlan) & Comandos se generan según el itinerario del plan de vuelo\\\hline
\end{tabularx}
\end{table}\label{tab:chp3:analisis:energia}
%····················

\begin{table}[ht!] \caption{Análisis de la arquitectura, según requerimientos operacionales, para él área de tolerancia a fallos}
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright}p{2.5cm} >{\raggedright}p{2.5cm} X}\hline
\multicolumn{3}{c}{\textbf{Área de tolerancia a fallos}}\\\hline
\textbf{Función} & \textbf{Módulo} & \textbf{Implementación} \\\hline

Estado de salud del sistema & Listener (HouseKeeping) & De forma periódica se generan comandos que revisen el estado del sistema y actualicen el repositorio de estados. Se pueden ejecutar comandos de reconfiguración, pasar a modos de fallo, desactivar módulos o subsistmas.\\

Mucho tiempo sin conexión con tierra & Listener (Communications) & Si no se estable comunicación con tierra luego de N días el sistema pasa a modo de fallo de comunicaciones, permitiendo bajar telemtría básica de manera automática o reiniciar el sistema.\\

Problemas con despliegue de antenas & Listener (Deployment) & Se chequean sensores que indica si las antenas se han desplegado. Se generan comandos que intenten desplegar las antenas.\\

Watchdog & Sistema Operativo & Se cuenta con un watchdog en el microcontrolador, que se reseta periódicamente. Reinicia el sistema si la aplicación no responde.\\

Fallos de hardware externo & NA & Se pueden generar comandos para que la EPS apague los buses de energía de los payloads y hardware externo\\

Watchdog Externo & Listener (HouseKeeping) & Generar comandos periódicamente que reseteen el watchdog externo, reiniciando el sistema ante fallas generales en el microcontrolador.\\\hline
\end{tabularx}\label{tab:chp3:analisis:toleranciafallos}
\end{table}
%·······························

El resultado de este ejercicio revela los módulos que son necesarios en el diseño de la arquitectura de software a nivel de aplicación, específicamente los \textit{listeners} que se deben implementar son:

\begin{itemize}
	\item \textbf{Communications:} Este \textit{listener} se encarga de controlar los eventos relacionados con el subsistema de comunicaciones, específicamente presta atención a la llegada de telecomandos que implican la ejecución de comandos en el sistema.
	
	\item \textbf{FlightPlan:} Este \textit{listener} tiene a cargo el control del plan de vuelo del satélite, concebido como un itinerario de comandos a ejecutar en un determinado momento. Se presta atención al reloj del sistema o bien a la información entregada por un subsistema de posicionamiento, dependiendo de la implementación.
	
	\item \textbf{HouseKeeping:} Este \textit{listener} tiene por función la ejecución de comandos relacionados con el control del estado del sistema mismo. Estas son acciones que se ejecutan periódicamente durante todo el funcionamiento del sistema, a diferentes intervalos según se requiera, por lo tanto la variable de interés para este \textit{listener} es el conteo de ticks interno del sistema operativo.
	
	\item \textbf{DebugConsole:} Este \textit{listener} tiene por función atender las órdenes entregadas a través de la consola serial y generar los comandos adecuados en un modo que desplieguen información útil sobre su ejecución. Si bien este módulo no tiene utilidad durante la misión, es de vital importancia para la etapa de desarrollo y previo al lanzamiento del satélite.
\end{itemize}

El módulo \textit{dispatcher} contará con las siguientes características, que permiten cumplir con los requerimientos de tolerancia a fallos y control del estado del sistema:
\begin{itemize}
	\item Recibir todos los comandos generados y decidir si serán enviados para su ejecución.
	\item Filtrar comandos que requieren mayor energía que la disponible en determinado momento.
	\item Llevar un registro de los comandos que se han generado
	\item Llevar un registro del resultado de la ejecución de comandos.
\end{itemize}

Respecto al módulo \textit{executer}, en el diseño actual se considera la utilización de sólo un \textit{executer} dado que el sistema no será utilizado bajo una alta demanda de ejecución de comandos según lo expresado en los requerimientos no operacionales y aprovechando la ventaja que implica no requerir una gran cantidad de elementos de sincronización entre procesos concurrentes.

La arquitectura se completa con los repositorios de datos, que según lo analizado deben ser tres:
\begin{itemize}
	\item \textbf{Repositorio de estados:} Provee acceso a todas las variables de estado del sistema, por ejemplo, información sobre el funcionamiento, estado de salud y parámetros de configuración actuales. La información en este repositorio suele estar presente en forma de \textit{flags}, contadores o registros de configuración. Dependiendo de la aplicación, algunos de estos datos pueden requerir almacenamiento persistente de modo de mantener el estado de funcionamiento entre reinicios.
	
	\item \textbf{Repositorio de datos:} Provee funcionalidades para almacenar y recuperar datos generales, como resultados de experimentos, registro de sucesos o telemetría general. Por lo general se requerirá de almacenamiento persistente y de gran capacidad.
	
	\item \textbf{Repositorio de comandos:} Este repositorio provee el acceso a todos los comandos disponibles en el sistema. Es usado tanto para construir el comando que se desea generar por parte de los \textit{listeners}, así como para determinar la función asociada al código que es recibido por el \textit{executer}.
\end{itemize}

Con esto, el resultado del diseño de la arquitectura de software queda detallado en la figura \ref{img:ch3:dis:arch} que muestra los módulos participantes y el flujo de información en esta arquitectura:

\figura{img/arch_suchai.pdf}{width=\textwidth}{Arquitectura de software para el control del satélite}{img:ch3:dis:arch}{!h}

Las capas inferiores en la arquitectura global no se ven afectados por los requerimientos operaciones, en cuanto su diseño e implementación es menos flexible y siempre necesaria para sostener la arquitectura de nivel de aplicación. En la capa de \textit{drivers} lo importante contar con la librerías de acceso a todos los dispositivos requeridos. La capa de sistema operativo actúa como caja negra en cuanto se utiliza una solución de terceros lo cual es ventajoso en cuanto la interfaz hacia el \textit{middelware} y hacia la capa de aplicación esté bien definida.
